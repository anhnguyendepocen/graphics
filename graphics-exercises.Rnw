%\VignetteIndexEntry{Strings and Ranges Practical}
%\VignettePackage{GeneticsHTSCourse}
%\VignetteEngine{knitr::knitr}

% To compile this document
% library('knitr'); rm(list=ls()); knit('DESeq2.Rnw')

\documentclass[12pt]{article}
\usepackage{wasysym,marvosym}
\newcommand{\usecase}{\textit{\textbf{Use Case: }}}
\newcommand{\exercise}{\textit{\textbf{Exercise: }}}
\newcommand{\notebell}{\bell}
\newcommand{\noteright}{\Pointinghand}
\newcommand{\textinfo}{\Info}
<<knitr, echo=TRUE, results="hide",echo=FALSE>>=
library("knitr")
opts_chunk$set(tidy=FALSE,dev="png",
               fig.width=8,fig.height=4.5,
               message=FALSE,eval=TRUE,echo=TRUE)
@ 

<<style, eval=TRUE, echo=FALSE, results="asis">>=
BiocStyle::latex()
@

\usepackage{ifthen} 
\newboolean{includethis} 
\setboolean{includethis}{true} 
\newcommand{\ifinclude}[1]{\ifthenelse{\boolean{includethis}}{#1}{}} 

\title{Exercises on Graphics and Data Manipulation in R}

\author{Mark Dunning}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}


\maketitle


\tableofcontents

\section{Introduction}

The data that you need for this practical are available at ......... Please download this zip file and extract to your computer. You should then change your working directory in RStudio to point to the directory that you have just created. Session -> Change Working directory.


At the end of some subsections you may find some {\color{red}{Optional Extensions}}. You can attempt these if you have time in the practical sessions, or on your own after the course.


\section{Plotting basics}

This section will provide you with practice on reading several different file formats into R

\subsection{Weather Data}

The dataset introduced in the slides concerns weather conditions in New York City from the summer of 1973. \footnote{More details are available (http://faculty.washington.edu/heagerty/Books/Biostatistics/DATA/ozonedoc.txt}. 


\exercise Read the ozone data into your Rstudio. Practice using the 'file.choose' to locate the file on your hard drive

<<echo=TRUE,eval=FALSE>>=
myfile <- file.choose()
ozone <- read.csv(myfile)
@

\exercise Verify that the dimensions and first few lines are as we expect. HINT: use the \Rfunction{dim} and \Rfunction{head} functions.


<<echo=FALSE>>=
ozone <- read.csv("data/ozone.csv")
@

<<>>=
dim(ozone)
head(ozone)
@



\exercise Make sure you know how to extract the Wind column from the data frame by i) selecting using the column number ii) selecting using the column name. Verify that you get the same answer.

<<>>=
ozone[,3]
ozone$Wind
@

\exercise Make a scatter plot with index on the x-axis and Wind speed on the y-axis


<<echo=FALSE>>=
plot(ozone$Wind)

@

\exercise Make a scatter plot to compare Wind speed and temperature

<<>>=
plot(ozone$Wind, ozone$Temp)
@

The \Rfunction{plot} function in R is flexible and will try to guess the most appropriate type of plot based on the data that you give it. If given a data frame with numeric data, it will make pairwise scatter plots of all variables. In our case, this will allow us to compare all combinations of variables on the same plot.

\exercise Say we want to compare Ozone, Solar Radiation, Wind and Temperature variables only. Create a new data frame that consists of only these columns and save as a variable.

<<>>=
subset <- ozone[,1:4]
@

\exercise Use the plot function on your new data frame. It should look something like the following;

<<eval=TRUE,echo=FALSE>>=
plot(ozone[1:4])
@


{\color{red}{[Optional Extensions]}}

The \Rfunction{cor} function can be used to calculate correlations between variables. If given a data frame, it will calculate all pairwise correlations.


<<eval=FALSE>>=
cor(ozone[,1:4],use="c")
@

We can also test the significance of the association between variables using \Rfunction{cor.test}

<<eval=FALSE>>=
cor.test(ozone[,1],ozone[,4])
@



<<>>=
mod <- lm(ozone[,4] ~ ozone[,1])
plot(ozone[,1],ozone[,4])
abline(mod)
@


\subsection{Life Expectancy data}

\exercise Data describing the life expectancy of males and females born in particular years are given in the file 'UKLifeExpectancy.tsv' \footnote{These data come from a Guardian blog of 8th June 2011 http://www.theguardian.com/news/datablog/2011/jun/08/life-expectancy-uk-data-health}. What function do you think you would use to read these data? Using your chosen function, read these data into RStudio and check the dimensions.

<<>>=
life <- read.delim("data/UKLifeExpectancy.tsv")
dim(life)
head(life)
@
HINT: You should get 243 columns and 4 rows.

\exercise Plot how the Male life expectancy rate changes over the years

<<>>=
plot(life$Age, life$Male.babies)
@


\exercise Plot the difference between Male and Female Life Expectancy

<<>>=
plot(life$Male.babies, life$Female.babies)
@


\exercise Visualise the Male life expectancy as a barplot. Which plot (scatter or barplot) displays the data in a better way?

<<echo=TRUE>>=
barplot(life$Male.babies)
@

\exercise Similarly, the following is a valid plot in R. Comment on whether the trends in the data are better displayed as a barplot or scatter plot

<<>>=
barplot(as.matrix(t(life[,c(2,3)])),beside=TRUE)
@



\subsection{Acute Bacterial Meningitis data}
These data concern 581 patients having acute viral, or acute bacterial meningitis \footnote{
http://lib.stat.cmu.edu/S/Harrell/data/descriptions/abm.html}. 

\exercise These data are stored in the file 'abm.csv'. What function would you use to read these data? Read the data in using your chosen function and check the dimensions. HINT: you should get 581 rows and 43 columns.

<<>>=
abm <- read.csv("data//ABM.csv")
@

\exercise Use the \Rfunction{table} to tabulate the sex variable. How many categories would you expect? How many are plotted? Make a barplot of the counts from the table.

<<>>=
barplot(table(abm$sex))
@



\exercise Retreive the 'year' variable from the data frame. Attempt to make a histogram of this variable. What do you notice?

<<>>=
abm$year[1:10]
@

You get an error in the following form

<<echo=FALSE>>=
err <- try(hist(abm$year),silent = TRUE)
cat(err)
@

The problem is that the raw data table uses the \Rcode{'.'} symbol to represent missing data. R interprets this as a character, and assumes that any columns that contain this character are all text. Thus, columns that should represent numeric values are incorrectly represented.

\exercise Read the table again, this time set the \Rcode{na.strings} argument to be the character \Rcode{'.'}.  

<<>>=
abm <- read.csv("data//ABM.csv",na.strings=".")
@

\exercise Repeat the histogram

<<>>=
hist(abm$year)
@


The \Rcode{abm} variable encodes whether each patient had either acute viral (abm = 0) or acute bacterial (abm=1) meningitis. 

\exercise Create a count table of abm status against gender and make a barplot of this table.

<<echo=FALSE>>=
table(abm$abm, abm$sex)
@

\exercise

<<>>=
counts <- table(abm$abm, abm$sex)
barplot(counts, beside=TRUE,legend = rownames(counts))
@


\section{Plot options}

In this part of the practical we will revisit some of the same datasets from the previous section, but introduce different ways in which we can customise and extend the basic plots.


\subsection{Life expectancy data}

\exercise Read the UK life expectancy data and plot the female life expectancy on the y axis against year on the x axis.  Then overlay the Male life expectancy data using the \Rfunction{points} function. Choose different colours for male and female. 

<<>>=
life <- read.delim("data/UKLifeExpectancy.tsv")
plot(life$Age, life$Female.babies, col="red",pch=15,xlab="Year", 
     ylab="Life Expectancy",main="Comparison of male and female life expectancy")
points(life$Age, life$Male.babies,col="blue",pch=14)
@

\exercise Add a legend in the top-left corner using the \Rfunction{legend} function. 

<<eval=FALSE>>=
legend("topleft", legend=c("Male", "Female"), col=c("red","blue"),pch=c(15,14))
@

\exercise We decide that we are only interested in the 20th century (i.e. years 1900 to 2000). Create a new plot that only displays years in this range by specifying an appropriate value for the \Rcode{xlim} argument.

<<>>=
plot(life$Age, life$Male.babies, col="red",pch=15,xlab="Year", 
     ylab="Life Expectancy",xlim=c(1900,2000))
points(life$Age, life$Female.babies,col="blue",pch=14)
@

The easiest way to combine several plots on the same page is to use the \Rfunction{par} function. \Rfunction{par} is used to pre-specify many plotting options \footnote{see ?par for details} by a series of named arguments, the most-common of which are the plot layout and margins. The argument to change the layout is \Rcode{mfrow} which has to be a vector in the form \Rcode{c(rows, columns)} to form a plot layout with the specified number of \textit{rows} and \textit{columns}. e.g. \Rcode{par(mfrow = c(rows,columns))}. The order in which plots are created will fill up the page in the required layout configuration.

\exercise Try and replicate the plot shown below. You will need to use the \Rfunction{par} function to set the layout of the plot to have one row and two columns. Also take care to make sure that you have the same y-axis in both plots.

<<eval=TRUE,fig.show='asis'>>=
par(mfrow=c(1,2))
plot(life$Age, life$Male.babies, col="red",pch=16,xlab="Year", 
     ylab="Life Expectancy",xlim=c(1900,2000),main="Male Life Expectancy",ylim=c(40,90))
grid()
plot(life$Age, life$Female.babies, col="blue",pch=17,xlab="Year", 
     ylab="Life Expectancy",xlim=c(1900,2000),main="Female Life Expectancy",ylim=c(40,90))
grid()
@


The life expectancy data also contains annotations about years in the 20th century when the two World Wars occurred and would presumably have an influence on the data.

<<eval=TRUE,echo=FALSE>>=
life[life$Annotations != "",]
@

The \Rfunction{abline} can be used to add horizontal and vertical lines to an existing plot. As always, you can find out more information about the function by doing \Rcode{?abline}. It can take slope and intercept values, plot the result of a linear model fit (outside the scope of today), or plot horizontal and vertical lines by setting the \Rcode{h} and \Rcode{v} arguments.

\exercise Use \Rfunction{abline} to add vertical lines to indicate periods in which the two world wars took place


<<eval=TRUE,fig.show='asis'>>=
par(mfrow=c(1,2))
plot(life$Age, life$Male.babies, col="red",pch=16,xlab="Year", 
     ylab="Life Expectancy",xlim=c(1900,2000),main="Male Life Expectancy",ylim=c(40,90))
abline(v=c(1914, 1918, 1939,1945),col="red",lty=2)
grid()
plot(life$Age, life$Female.babies, col="blue",pch=17,xlab="Year", 
     ylab="Life Expectancy",xlim=c(1900,2000),main="Female Life Expectancy",ylim=c(40,90))
abline(v=c(1914, 1918, 1939,1945),col="blue",lty=2)
grid()
@

The \Rfunction{text} function (\Rcode{?text}) is another function that can modify an existing plot. In a similar manner to \Rfunction{points}, it has arguments to specify the x and y coordinates at which text will be written. It also needs a \Rcode{labels} argument which can be used to specify the text to be written to the plot.

\exercise Add text annotations to indicate when World War I and World War II started

<<eval=TRUE,fig.show='asis'>>=
par(mfrow=c(1,2))
plot(life$Age, life$Male.babies, col="red",pch=16,xlab="Year", 
     ylab="Life Expectancy",xlim=c(1900,2000),main="Male Life Expectancy",ylim=c(40,90))
abline(v=c(1914, 1918, 1939,1945),col="red",lty=2)
text(x = c(1914,1935), y = c(90,90), labels = c("WW1", "WW2"),srt=45)
grid()
plot(life$Age, life$Female.babies, col="blue",pch=17,xlab="Year", 
     ylab="Life Expectancy",xlim=c(1900,2000),main="Female Life Expectancy",ylim=c(40,90))
abline(v=c(1914, 1918, 1939,1945),col="blue",lty=2)
text(x = c(1914,1935), y = c(90,90), labels = c("WW1", "WW2"),srt=45)
grid()
@

{\color{red}{[Optional Extensions]}}

Other arguments to the \Rfunction{text} function include the option to rotate the text (\Rcode{srt}) and use a different font (\Rcode{font}).

\exercise See if you can rotate the text by 45 degrees and use a bold font

<<>>=
par(mfrow=c(1,2))
plot(life$Age, life$Male.babies, col="red",pch=16,xlab="Year", 
     ylab="Life Expectancy",xlim=c(1900,2000),main="Male Life Expectancy",ylim=c(40,90))
abline(v=c(1914, 1918, 1939,1945),col="red",lty=2)
text(x = c(1914,1935), y = c(90,90), labels = c("WW1", "WW2"),srt=45)
grid()
plot(life$Age, life$Female.babies, col="blue",pch=17,xlab="Year", 
     ylab="Life Expectancy",xlim=c(1900,2000),main="Female Life Expectancy",ylim=c(40,90))
abline(v=c(1914, 1918, 1939,1945),col="blue",lty=2)
text(x = c(1914,1935), y = c(90,90), labels = c("WW1", "WW2"),srt=45)
grid()
@

The \Rfunction{mtext} function allows text to be written in margins around the plot, rather than inside. 

\exercise Use the \Rfunction{mtext} function to write the text labels above the plot. 

<<>>=
par(mfrow=c(1,2))
plot(life$Age, life$Male.babies, col="red",pch=16,xlab="Year", 
     ylab="Life Expectancy",xlim=c(1900,2000),main="Male Life Expectancy",ylim=c(40,90))
abline(v=c(1914, 1918, 1939,1945),col="red",lty=2)
mtext(side = 3,at = c(1914,1935), text = c("WW1", "WW2"),srt=45)
grid()
plot(life$Age, life$Female.babies, col="blue",pch=17,xlab="Year", 
     ylab="Life Expectancy",xlim=c(1900,2000),main="Female Life Expectancy",ylim=c(40,90))
abline(v=c(1914, 1918, 1939,1945),col="blue",lty=2)
mtext(side = 3,at = c(1914,1935), text = c("WW1", "WW2"),srt=45)
grid()
@




\subsection{Weather data}

\exercise Read the Weather data back into R. As seen in the slides, use the formula annotation (\Rcode{y~x}) to produce a boxplot with the temperature on the y axis, and month on the x axis.

<<>>=
ozone <- read.csv("data/ozone.csv")
boxplot(ozone$Temp ~ ozone$Month,
        xlab="Month",ylab="Temperature")
@

\exercise Repeat the plot with a different colour for each box. First create a vector with five valid colour names (i.e. the name appears in the output of \Rfunction{colours()}) and use this as the col argument to \Rfunction{plot}.

<<>>=
boxplot(ozone$Temp ~ ozone$Month,col=c("Red", "Orange", "Yellow", "Green","Blue"),
        xlab="Month",ylab="Temperature")
@

\exercise Now, load the \Rpackage{RColorBrewer} package and see what palettes are available using \Rfunction{display.brewer.all()}. Use the \Rfunction{brewer.pal} function to create a palette of length 5 from one of the available options and use this palette to colour the boxplot.

<<>>=
library(RColorBrewer)
mypal <- brewer.pal(5, "Set1")
boxplot(ozone$Temp ~ ozone$Month,col=mypal,
        xlab="Month",ylab="Temperature")
@

We will now re-visit the scatter plot of Ozone level and Temperature

<<echo=TRUE,eval=TRUE>>=
plot(ozone$Temp,ozone$Ozone,pch=16)
@

Lets consider the steps required to colour each point according to the month that the observations were made. Our goal is to produce a vector of length \Sexpr{nrow(ozone)}, where each item in the vector is the colour to be used to plot the corresponding point.

Step 1: Using the table function on the Month variable, you will see how many observations are present for each month

<<>>=
table(ozone$Month)
@

For simplicity, lets say we want to use \Rcode{"red"}, \Rcode{"orange"}, \Rcode{"yellow"}, \Rcode{"green"} and \Rcode{"blue"} to represent the colours for each month.

\exercise Create a vector of the string \Rcode{"red"} repeated 31 times and assign it to a variable. These will be the colours that data points for the first month will be plotted in. HINT Use the \Rfunction{rep} for this task.

<<>>=
vec1 <- rep("red", 31)
@

\exercise Repeat the same exercise to create colour vectors of the appropriate length for all the other months

<<>>=
vec2 <- rep("orange", 30)
vec3 <- rep("yellow", 31)
vec4 <- rep("green", 31)
vec5 <- rep("blue", 30)
@

\exercise Now combine all your vectors together and use this as the col argument when creating the scatter plot. Check that the length of your combined vector is \Sexpr{nrow(ozone)}. You should get the following plot;

<<echo=FALSE>>=
vec1 <- rep("red", 31)
vec2 <- rep("orange", 30)
vec3 <- rep("yellow", 31)
vec4 <- rep("green", 31)
vec5 <- rep("blue", 30)
cols <- c(vec1,vec2,vec3,vec4,vec5)
plot(ozone$Temp,ozone$Ozone,pch=16,col=cols)
@

{\color{red}{[Optional Extensions]}}

\exercise Create a legend in the top-left corner of the plot

<<echo=FALSE>>=
vec1 <- rep("red", 31)
vec2 <- rep("orange", 30)
vec3 <- rep("yellow", 31)
vec4 <- rep("green", 31)
vec5 <- rep("blue", 30)
cols <- c(vec1,vec2,vec3,vec4,vec5)
plot(ozone$Temp,ozone$Ozone,pch=16,col=cols)
legend("topleft", col=c("red","orange","yellow","green","blue"),legend = 5:9,pch=16)
@

\exercise Rather than using numbers to represent month, use abbreviated month names stored in the built-in \Rcode{month.abb} vector


<<echo=FALSE>>=
vec1 <- rep("red", 31)
vec2 <- rep("orange", 30)
vec3 <- rep("yellow", 31)
vec4 <- rep("green", 31)
vec5 <- rep("blue", 30)
cols <- c(vec1,vec2,vec3,vec4,vec5)
plot(ozone$Temp,ozone$Ozone,pch=16,col=cols)
legend("topleft", col=c("red","orange","yellow","green","blue"),legend = month.abb[5:9],pch=16)
@

\exercise Check out the help page for \Rfunction{rep} (\Rcode{?rep}), and in particular the \Rcode{times} argument. See if you can construct the vector of colours in a more efficient manner.

<<>>=
cols2 <- rep(mypal, times = table(ozone$Month))
plot(ozone$Temp,ozone$Ozone,pch=16,col=cols2)

@

\section{Data Manipulation - Worked Examples}

\subsection{Calculating new variables}

In the section, we take data in the format that GraphPad Prism requires for survival analysis, and manipulate them so we can do the analysis in R. The data are to be found in the \file{Two groups.txt} file.

\exercise Read the raw survival data into R and check the dimensions as usual. Create a \Rcode{Time} variable to store the time of each observation.

<<echo=TRUE>>=
library(survival)
sdata <- read.delim("data/Two groups.txt")
head(sdata)
Time <- sdata$Days.elapsed
@

We also need \Rcode{Group} and \Rcode{Event} information for the survival analysis, but these are less straightforward to obtain from the data frame. Recall that the group needs to be the same length as the number of observations and a particular item indicates which group the observation belongs to. \\

In our dataset, we can identify which group each observation belongs to by looking at the second column (\textit{Control}); if there is a value of 0 or 1 in this column then the observation is in the \textit{Control} group. Similarly, if there is a 0 or 1 in the third column (\textit{Treated}) then the observation belongs to the Treated group.

\exercise Create a vector of the correct length that will describe which group each observation belongs to. HINT: You may wish to use the \Rfunction{rep} function for this.

<<echo=TRUE>>=
Group <- c(rep("Control",8), rep("Treated", 9))
@

The \Rfunction{is.na} function is a useful for obtaining a logical (i.e. \Rcode{TRUE} or \Rcode{FALSE}) vector for determining the observations in a vector that are \textit{missing values}. 


\exercise Create a vector, \Rcode{Event}, that is the same as the \Rcode{Control} column in the data frame. Use \Rfunction{which} in conjuction with \Rfunction{is.na} to identify the values that are missing. Replace the corresponding indices in the \Rcode{Event} variable with entries from the \Rcode{Treated} column.

<<echo=TRUE>>=
Event <- sdata$Control
Event[which(is.na(Event))] <- sdata$Treated[which(is.na(Event))]
@

\exercise Produce the survival curve using the following steps.

<<echo=TRUE,eval=TRUE>>=
library(survival)
SurvData <- Surv(Time,Event)
plot(survfit(SurvData ~ Group))
@


Now lets return to the Life Expectancy data. Previously we visualised the life expectancy recorded for each year to look for trends. However, we will now create a new variable that will allow us to split the data by \textit{decade}.

\exercise Read the Life Expectancy data into R

<<echo=TRUE>>=
life <- read.delim("data/UKLifeExpectancy.tsv")
@


\exercise Create a subset of the data that contains just the years 1900 - 2000. 

<<echo=TRUE>>=
centdata <- life[life$Age > 1900 & life$Age < 2001,]
@

\exercise Create a new variable that captures the decade

<<echo=TRUE>>=
decade <- substr(centdata$Age, 3, 3)
@

\exercise Create a boxplot that shows the increase in Female life expectancy for each decade

<<echo=TRUE>>=
boxplot(centdata$Female.babies ~ decade,col="mistyrose")
@

Boxes to show the increase in Male life expectancy over the same period can be added.

<<echo=TRUE,eval=TRUE>>=
boxplot(centdata$Female.babies ~ decade,col="mistyrose",xlab="Decade",
        ylab="Life Expectancy")
boxplot(centdata$Male.babies ~ decade,col="steelblue",add=TRUE)
legend("topleft", fill=c("mistyrose", "steelblue"),legend=c("Female","Male"))
@
{\color{red}{[Optional Extensions]}}

<<echo=TRUE,eval=TRUE>>=
boxplot(centdata$Female.babies ~ decade,col="mistyrose",xlab="Decade",
        ylab="Life Expectancy",axes=FALSE)
boxplot(centdata$Male.babies ~ decade,col="steelblue",add=TRUE,axes=FALSE)
declabel <- unique(paste0(decade, "0s"))
axis(side=1, at = 1:10,labels = declabel,las=2)
axis(2)
box()
legend("topleft", fill=c("mistyrose", "steelblue"),legend=c("Female","Male"))
@



\subsection{Combining data from multiple files}

In this section we will consider the published data from the NKI breast cancer series. This is a series of 295 breast cancer patients that have been used to identify and validate various gene expression signatures. Typically, such datasets are spread over various files which give sample and feature annotation, and the actual gene expression values themselves. 

<<>>=
emat <- read.delim("data/NKI295.exprs.txt",stringsAsFactors=FALSE)
fmat <- read.delim("data/NKI295.fdata.txt")
pmat <- read.delim("data/NKI295.pdata.txt")
@

<<>>=
dim(emat)
dim(pmat)
@

<<>>=
colnames(emat)[1:10]
pmat[1:10,1]
@

<<>>=
emat[1:10,1]
fmat[1:10,]
@

\subsection{Subsetting the patients}

\exercise Find the sample names of the ER negative patients. You will first need to identify which column in the phenotypic data holds the ER status of each patient.

<<>>=

which(pmat$ER == "Negative")

erNegSamples <- pmat$sampleNames[which(pmat$ER == "Negative")]
@

\exercise Now match these sample names to the columns in the expression matrix

<<>>=
erNegMatix <- emat[,match(erNegSamples, colnames(emat))]

@


\subsection{Retrieving the data for a particular gene}

\exercise Find the probe ID that corresponds to the gene symbol "ESR1"

<<>>=

grep("ESR1", fmat$symbol)
fmat$probeID[grep("ESR1", fmat$symbol)]
@

\exercise Match the probe ID that you just found to relevant row in the expression matrix

<<>>=
match("18904", emat[,1])

erVals <- emat[18889,-1]
@

\subsection{Correlate gene expression with clinical variables}

\exercise Make a boxplot of ESR1 expression against ER status

<<>>=
boxplot(as.numeric(erVals) ~ pmat$ER)
@



\end{document}
