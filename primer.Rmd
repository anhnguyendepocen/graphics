---
title: 'Data  Manipulation and Visualisation: An R primer'
author: "Mark Dunning and Mike Smith"
date: "09/09/2014"
output: html_document
toc: yes
---

#Introduction

This document will guide you through the key concepts and techniques required to manipulate and process data in R. 

1. Read the data into R
  + What format are the data in? 
2. Manipulate the data
  + What columns / rows are needed for the analysis? Do any additional calculations need to be performed?
3. Plot the data
  + What type of plot do you need to convey your message? What type of data do you need for the plot
  
#Recommended references

Much [freely-available](http://cran.r-project.org/other-docs.html) documentation about R is available from CRAN. In particular, the R [reference card](http://cran.r-project.org/doc/contrib/Short-refcard.pdf) is recommended. 

There is no shortage of other R tutorials available online. Some that has provided particular inspiration in the construction of this document are listed below:

- [R cookbook](http://www.cookbook-r.com/)
- [Quick-R](http://www.statmethods.net/)
- [UC Riverside R & Bioconductor manual](http://manuals.bioinformatics.ucr.edu/home/R_BioCondManual)

#Running R and RStudio

Our recommended way of using R is via the RStudio interface. Like R, this software is freely to download and available on any operating system. You will need to download the latest versions of R and RStudio.

##Installing R

Download links for R can be found on the [CRAN](http://cran.r-project.org/) page (Comprehensive R Archive Network). There are separate downloads for [Windows](http://cran.r-project.org/bin/windows/base/R-3.1.1-win.exe) and [Mac OSX](http://cran.r-project.org/bin/macosx/R-3.1.1-snowleopard.pkg). Unix, or advanced users will need to find the appropriate link to their distribuion, or consider downloading the [source code](http://cran.r-project.org/src/base/R-3/R-3.1.1.tar.gz). 

##Installing RStudio

RStudio was created by a third-party company and available as a free download. You can find an *installer* for your platform on the [download](http://www.rstudio.com/products/rstudio/download/) page. Make sure that you are downloading the **Desktop** version of RStudio, rather than the *server* version.

##About this document

This document was written in RStudio using the **markdown** format. If you see a section like this, you can copy-and-paste the text into RStudio and execute it. 
 
```{r eval=FALSE}
print("Hello World")
```


Often the output from R will be displayed after the R command. You can compare this to the output that you get from running the command yourself.

```{r}
print("Hello World")
```

Sometimes the graphics produced by R will be displayed too.

```{r}
plot(runif(1:10))
```

#Reading data into R

The first stage of doing an analysis in R is to import some raw data that is presented a *spreadsheet-like* format. By which we mean data organised in rows and columns like we usually see in a spreadsheet program such a Microsoft Excel.

Unfortunately, importing data can be the source of many errors and frustrations; sometimes halting an analysis before it has even begun. *Well-formatted* data should be easy to read using a small selection of functions, although the user will have to decide which function to use. The key first steps are to locate the relevant raw data file on your hard drive and decide what format it is in. As a *rule-of-thumb*, [tab-delimited](#tab-delimited-file) files have file extensions *.txt* or *.tsv*, whereas [comma-separated](#comma-separated-file) have an extension *.csv* .

More information on reading files into R can be found online at the [R data manual](http://cran.r-project.org/doc/manuals/R-data.html) or [an introduction to data cleaning with R](http://cran.r-project.org/doc/contrib/de_Jonge+van_der_Loo-Introduction_to_data_cleaning_with_R.pdf)

##Specify a path to the file

R needs to know where the file is located on your hard drive in order to read it. If the file is located within your *working directory* then you can just specify the name of the file. You can find out the location of your working directory using the `getwd` function.

```{r eval=FALSE}
getwd()
```

You can also interrogate the contents of your working directory using the `dir` function

```{r eval=FALSE}
dir()
```
The `dir` function has a useful argument `pattern` which will list files that contain a particular *string* of text. For instance, we can list all files of type `.csv` and `.txt` in the current working directory that could potentially be read into R.

```{r eval=FALSE}
dir(pattern=".csv")
dir(pattern=".txt")
```

If the file you want to read is not in your working directory, then you will need to specify thepath to the file. A useful function in this situation is `file.choose`, which will open a dialog box allowing you to navigate to the file. The location can be stored as a variable.

```{r eval=FALSE}
myfile <- file.choose()
```

When specifying the file location manually, it has to giving within *quote marks*, as in the following example


```{r}
myfile <- "PrimerExamples/Indepentent two-sample t-test_v2_long.txt"
```

We will now discuss various ways of loading tabular data into R. The examples should cover most file types that you might encounter (e.g. csv, txt, tsv, xlsx files). If you have an example file that doesn't seem to fit any of these example, please let us know. Please note that R is not able to import GraphPad Prism files, as this file format is proprietary. You will have to use a commercial version of Prism to export the data table into a text-file. 

Once a file has been read into R, we recommend that you **check the dimensions and contents**. Sometimes R will read a file without error, but may not have been able to interpret the structure of the data correctly, which will cause problems for further analysis.

##What separator should be used?

```{r}
count.fields("PrimerExamples/Indepentent two-sample t-test_v2_long.txt",sep="\t")
count.fields("PrimerExamples/Indepentent two-sample t-test_v2_long.txt",sep=",")

```


##Tab-delimited file

As a *rule-of-thumb*, tab-delimited files have file extensions *.txt* or *.tsv*. If your file is tab-delimited and you have specified the location using the previous section, you will be able to use the `read.delim` function. The `file.exists` is a useful function for checking that the file location is correct; returning `TRUE` if so.

```{r}
myfile <- "PrimerExamples/Indepentent two-sample t-test_v2_long.txt"
file.exists(myfile)
mydata <- read.delim(myfile)
```

Assuming that the function does not produce an error, you should now have a variable `mydata` in your R workspace. This is *data frame* object, described in more detail in the [appendix](#data-frames). At this point, it is highly recommended that you check the contents of the variable. The `View` command should open a new tab in RStudio.

```{r eval=FALSE}
View(mydata)
```

The dimensions and structure of the data can be further interrogated using the following [useful functions](#useful-functions-to-know).

```{r}
dim(mydata)
str(mydata)
head(mydata)
```

In this case, the object has `r ncol(mydata)` columns and `r nrow(mydata)` rows; as we would expect.

Now notice what happens if we read the file by (incorrectly) calling the `read.csv` function on a *tab-delimited* file

```{r}
myfile <- "PrimerExamples/Indepentent two-sample t-test_v2_long.txt"
mydata <- read.csv(myfile)
dim(mydata)
str(mydata)
head(mydata)
```

R was able to read the file without error, but the dimensions of the resulting object are incorrect. In particular, it has been unable to separate the columns because an incorrect s
eparator was used (a `,` rather than a tab). 

##Comma-separated file

Files that have columns separated by commas can be read using the `read.csv` function. The file location needs to be specified by either using the `file.choose` function as follows;

```{r eval=FALSE}
myfile <- file.choose()
```

Or by specifying the path to the file within quote marks. Once the file has been read, we check the dimensions and general structure.

```{r}
myfile <- "PrimerExamples/One-sample t-test.csv"
mydata <- read.csv(myfile)

dim(mydata)
str(mydata)
head(mydata)
```


##Excel file

R is even able to read Excel spreadsheets. This requires an additional *package* to be installed; `gdata`. This package is loaded as follows;

```{r}
library(gdata)
```

It is not uncommon for a package to print text to the screen upon loading. You should not mistake this text for an *error* message.

However, if you do not have `gdata` installed you will get an error message in the following form.

```{r echo=FALSE,warning=FALSE}

error <- try(library(foo),silent = TRUE)
error[1]
```

If this error occurs, the package will need to be installed and then loaded
```{r,eval=FALSE}
install.packages("gdata")
library(gdata)
```

Note that you will only need to install the package once for a particular R *version*. However, you will need to load this library in every new R session when you require the functionality to read Excel files.

We can now call the `read.xls` function from `gdata` to create a *data frame* from your input file.

```{r}
myfile <- "PrimerExamples//Indepentent two-sample t-test_v2_long.xlsx"

mydata <- read.xls(myfile)
dim(mydata)
head(mydata)
```

##Specifying a different separator

If your file is neither `tab` or `comma` separated, then `read.csv` and `read.delim` will not be able to read the file correctly with their default arguments. In the following example, we try and use to `read.csv` on a file with columns that are separated with a space (`" "`).

```{r}
myfile <- "PrimerExamples/space-separated.csv"
mydata <- read.csv(myfile)
dim(mydata)
head(mydata)
```

We see that the dimensions of the data object are incorrect. Both `read.csv` and `read.delim` have the option to specify a different separator. 

```{r}
mydata <- read.csv(myfile, sep=" ")
dim(mydata)
head(mydata)
```


##SPSS file
R is able to read data created by SPSS. This requires an additional *package* to be loaded; `foreign`.

```{r}
library(foreign)
```

You only need to load the library *once* per R-session. We can now call the `read.spss` function from `foreign` to create a *data frame* from your input file.

```{r}
myfile <- "PrimerExamples/p004.sav"

mydata <- read.spss(myfile,to.data.frame = TRUE)
dim(mydata)
head(mydata)
```

The `foreign` package is also able to read files in `SAS` (`read.export`) and `STATA` (`read.dta`) formats, but sadly not Graphpad Prism.

##Further options for reading files
Sometimes we might be faced with 'messy' data that do not have a straightforward format of rows and columns. 
`read.csv` and `read.delim` are in fact specialised versions of a generic `read.table` function. This function has many options to allow finer-grain control over how files are read into R, as you will see from the manual page. 

```{r eval=FALSE}
?read.table
```

We now summarise the options that prove to be most useful

###Skipping lines

By default, R will assume that your data table starts on the first line of the file and that the column headers are found on the first line. However, sometimes the data table can be preceeded with several lines of header information. The header may contain useful information for the user, such as the date the file was generated and software versions etc, but is not relevant when we try and read the data table into R. 

If we try and use the default settings of `read.delim` to read a tab-delimited file with arbitrary header information, the following occurs. In this case, the file contains counts for a number of barcodes deteceted on a particular lane of sequencing. Naturally, we might want to read these data into R and perform some exploratory analysis and diagnostics.

```{r}
myfile <- "PrimerExamples/file-with-header.txt"
mydata <- read.delim(myfile)
head(mydata)
```

You will notice that R has tried to interpret the header information as lines of the data table, and therfore the data is not imported correctly.

Fortunately, both `read.csv` and `read.delim` have a `skip` argument so that we can start reading the data table from a pre-determined position in the file. In this example we have to *skip* the first 11 lines of the file in order to reach the table.

```{r}
mydata <- read.delim(myfile, skip=11)
head(mydata)
```

In practice, you may have to try different values for the `skip` argument in order to obtain the correct result. Use of the `head` and `dim` functions should help you determine when the data has been read correctly.

###Files with no header

Conversely, sometimes files can be created without any column names. By default, R assumes that the first row in the file contains column headings. This can have unexpected consequences when a file does not contain column headings. 


```{r}
myfile <- "PrimerExamples/file-with-no-header.csv"
mydata <- read.csv(myfile)
head(mydata)
dim(mydata)
colnames(mydata)
```

In this example, R took the first line of the file to be the column headings and so we have column names `r paste(colnames(mydata),collapse=" & ")`. Moreover, the data frame produced has `r nrow(mydata)` rows rather than `r nrow(mydata)+1`. The remedy is to set the `header` argument to `FALSE`. Both `read.csv` and `read.delim` are able to recognise the `header` argument.

```{r}
myfile <- "PrimerExamples/file-with-no-header.csv"
mydata <- read.csv(myfile,header=FALSE)
head(mydata)
dim(mydata)
colnames(mydata)
```

You can modify the column names of the `mydata` object.

```{r}
colnames(mydata) <- c("Month", "Value")
```


###Reading a pre-determined number of lines

It is possible to read only a fixed number of rows by using the `nrows` argument. Useful if you just want to see the first few lines in a file.

```{r}
subset <- read.csv("PrimerExamples/One-sample t-test.csv",nrows=4)
subset
```



###Invalid characters

Consider the following file, which we are told has the expression levels of 20 genes. We use `read.delim` to read the file (as it is tab-delimited)

```{r}
myfile <- "PrimerExamples/DiffGenes.tsv"
mydata <- read.delim(myfile)
head(mydata)
dim(mydata)
```

However, the number of rows comes out as `r nrow(mydata)`. We can use the `tail` function (analagous to `head`) to look at the last few rows in the file.

```{r}
tail(mydata)
```

Problems of this nature are usually due to an extraneous quotation mark `"` or `'` being found somewhere in the file. We can tell `read.delim` to ignore quotation marks in the following way. Of course, we could have editted the raw data to remove the quote mark, but this might not be practical for larger files.

```{r}
mydata <- read.delim(myfile,quote = "")
```

We now look at a second example file, which upon first impressions loads without any problems.

```{r}
myfile <- "PrimerExamples/DiffGenes2.tsv"
mydata <- read.delim("PrimerExamples/DiffGenes2.tsv",header=FALSE)
head(mydata)
dim(mydata)
```
A natural data exploration step would be to calculate the mean of the gene expression values, which are stored in the second column. However, we cannot do this even if we tell R to ignore any `NA` values. We can discover that the second has not been treated as numeric values by R.

```{r}
mean(mydata[,2])
mean(mydata[,2],na.rm=TRUE)
summary(mydata[,2])
str(mydata)
```

The issue is that our collaborator has chosen to use a `?` to denote a missing value in the second column. This causes R to think that this column contains characters rather than numbers. A solution is to use the `na.strings` argument to specify a particular value that is used to denote a missing value.

```{r}
myfile <- "PrimerExamples/DiffGenes2.tsv"
mydata <- read.delim("PrimerExamples/DiffGenes2.tsv",header=FALSE,na.strings="?")

head(mydata)
str(mydata)
summary(mydata[,2])
mean(mydata[,2],na.rm=TRUE)
```



###If all else fails...

The `readLines` function can be used. This is a *low-level* function for reading data into R and reads each line in the file as avector, along with the characters used to separate the columns. For example, if we read a file with a `.txt` extension.

```{r}
temp <- readLines("PrimerExamples/Indepentent two-sample t-test_v2_long.txt")
head(temp)
```

The fact that a `\t` character can be seen in each item of the vector tells us that we should be using the `read.delim` function. Likewise, with a `.csv`

```{r}
temp <- readLines("PrimerExamples/One-sample t-test.csv")
head(temp)
```
each item in the vector has a `,` character which is used to separate the data into two columns. We should read this file using `read.csv`

If we have a file with `header` information, we can use `readLines` to identify the line on which the data table begins, and hence what we should use as a `skip` argument.

```{r}
temp <- readLines("PrimerExamples/file-with-header.txt")
temp[1:15]
```
In this case, we can see the column headings for the data table start on line 12. Thus, we should read the file with `skip=11` in the function `read.delim`.


##Strings as factors

R is primarily a statistics language so much of its functionality is geared-up to make things ameanable to statistical analysis. For instance, it will prefer to work with [Factors](#factors) rather than characters. When a data table is read into R, as stored as a data frame, the default behaviour is to store character [vectors](#vectors) as factors. This may not always be neccesary. 

```{r}
myfile <- "PrimerExamples/One-sample t-test.csv"
mydata <- read.csv(myfile)
str(mydata)
```

We do not plan to take advantage of this behaviour and can easily work with the months in character form. Therefore we can set the argument `stringsAsFactors=FALSE`

```{r}
myfile <- "PrimerExamples/One-sample t-test.csv"
mydata <- read.csv(myfile,stringsAsFactors=FALSE)
str(mydata)
```



##Data in multiple files

If the dataset you want to import is spread over several data files, you will have to read each file individually and combine the respective data frames into a single object. 

##Data from online sources

The `repmis` package (misellaneous tools for reproducible research) contains useful functions to retrieve online data. 

```{r eval=FALSE}
install.packages("repmis")
```

A useful resource for such data is the Github page of [Vincent Arel-Bundock](http://vincentarelbundock.github.io/Rdatasets/datasets.html), which has csv version of example datasets found in many R packages. We can download data from this page using the `source_data` function. For example, if we browse the web page we can see there is an dataset containing Ovarian Cancer survival data. We can copy the URL of the corresponding `.csv` file and paste into R.

```{r eval=FALSE}
library(repmis)
surv <- source_data("http://vincentarelbundock.github.io/Rdatasets/csv/survival/ovarian.csv")
head(surv)
```


#Using pre-built datasets

R comes with the `datasets` package which contains many example datasets ready for exploration and analysis. To see what datasets are available, along with brief descriptions, enter the following;

```{r eval=FALSE}
data()
```

If you see a dataset that might be interesting (e.g. the `DNase` dataset which measures the density of a protein at various concentrations), it can be loaded into R in the following manner. 

```{r}
data(DNase)
head(DNase)
```
Further details on the dataset can be found on its help page.
```{r eval=FALSE}
?DNase
```


```{r echo=FALSE}
par(ask=FALSE)
```

Moreover, example plots and code can be generated using the `example` function.

```{r}
example(DNase)
```

#Data manipulation

The term *data manipulation* is used here to describe the steps that occur after having [read data into R](#reading-data-into-r) and prior to [plotting](#plotting) and/or [statistical analysis](#statistical-analysis).

##Selecting columns from a data frame

We will illustrate using the `mtcars` data, one of the in-built datasets in R. We can load the data using the `load` function and query the dimensions and print the first few lines using `dim` and `head`. 

Subsetting in R **always** uses the `[row,column]` notation.

###By column number

```{r}
data(mtcars)
head(mtcars)
dim(mtcars)
```

Columns in the data frame can be retrived using a numeric index. The *first* column can be retrieved by specifying the *column* as 1 in `[row,column]` notation. However, we if we want values for all observations (rows) we can neglect to specify a value before the `,`. e.g.


```{r}
mtcars[,1]
```

The output is a [vector](#vectors) and it's length will be the same as the number of rows in the data frame. Note that we have not altered the `mtcars` data frame in any way. It will still have the same number of columns. 

```{r}
dim(mtcars)
```

If we want to do some further calculations on the vector we have extracted, we need to assign it to a variable

```{r}
myvector <- mtcars[,1]
length(myvector)
myvector
```


The notation is very similar to retrieve the second column

```{r}
myvector <- mtcars[,2]
length(myvector)
myvector
```

If we want to retrieve the first and second columns *at the same time*, we can construct a [vector](*vectors), using the `c` function, comprising the indices we want to retrive and use this in the `[]` notation. The result is a *data frame* itself.

```{r}
mydf <- mtcars[,c(1,2)]
head(mydf)
dim(mydf)
```

We can also use the `:` shortcut to generate a sequence of consecutive integers

```{r}
mydf <- mtcars[,c(1:3)]
head(mydf)
dim(mydf)
```

###By column name

We can also extract data using the names of columns
```{r}
colnames(mtcars)
mydf <- mtcars[,"mpg"]
head(mydf)
```

The column names can be combined using the `c` function
```{r}
mydf <- mtcars[,c("mpg","cyl")]
head(mydf)
```


##Row subsetting

###Subset rows by index


```{r}
mtcars[1:5,]
```

###`%in%`
A common task in exploratory data analysis is to ask whether a specific value or values exists in a larger R object.  For example you may want to know whether a specific gene name appears in a long list of names you've just read in.  To achieve this we can use the `%in%` command.

```{r eval=TRUE}
"BRCA1" %in% c("RAS", "MYC", "BRCA1", "TP53")
```

In the case above we were only interested in a single text query.  The example below demonstrates both that `%in%` is equally happy working with numeric values, and that a [vector](#vectors) of queries can be used in a single command.  Here a vector of `TRUE` or `FALSE` values the same length as the number of queries will be returned. This is far more efficient that trying each in turn.

```{r eval=TRUE}
c(1,5,11) %in% 1:10
```

In our particular example....

```{r}
myInd <- rownames(mtcars) %in% c("Merc 230", "Merc 280")
myInd
mtcars[myInd,]
```

`myInd` is a *logical* [vector](#vectors) (i.e. either `TRUE` or `FALSE`) of length `r nrow(mtcars)`, where each denotes whether that particular rownames is one of the supplied vector. This logical vector can then be used to subset the data frame.

###match,

While the `%in%` command is useful for telling you whether a query appears somewhere, it doesn't specify where in the subject you will find it.  However there are several ways to achieve just this, where perhaps the most straightforward is `which()`.

```{r eval=TRUE}
which(c("RAS", "MYC", "BRCA1", "TP53") == "BRCA1")
```

However this approach falls down if one is interested in multiple queries.
```{r eval=TRUE}
which(c("RAS", "MYC", "BRCA1", "TP53") == c("BRCA1", "RAS"))
```
To avoid the confusion this could cause, it is better the employ the function `match()`


```{r eval=TRUE}
match(x = c("BRCA1", "MYC"), table = c("RAS", "MYC", "BRCA1", "TP53"))
```

```{r}
myInd <- match("Merc 230", rownames(mtcars))
myInd
mtcars[myInd,]

```


###grep 

```{r}
myInd <- grep("Merc", rownames(mtcars))
myInd
mtcars[myInd,]
```


##Adding new columns / variables

##Re-ordering data frames


```{r}
order(mtcars[,"mpg"])
mtcars[order(mtcars[,"mpg"]),]
```

```{r}
order(mtcars[,"mpg"],decreasing=TRUE)
mtcars[order(mtcars[,"mpg"],decreasing=TRUE),]
```

```{r}
sort(rownames(mtcars))
sort(mtcars[,"mpg"])
```

##Text manipulation

###nchar

```{r}
nchar(rownames(mtcars))
```

###toupper

```{r}
toupper(rownames(mtcars))
```


###gsub

###strsplit

```{r}
strsplit(rownames(mtcars)," ")
```


###substr

```{r}
substr(rownames(mtcars), 1,4)
```


##Calculating summary statistics

##apply, tapply, aggregate

#Writing data to a file

#Plotting

##The plot function

`plot` is the generic function in R

##Exporting a plot

R is able to save graphics in a variety of formats..

##Changing the plot appearance

How the `par` function works....

##Creating a layout

`par(mfrow=c...)`

##Adding a legend

`legend("topleft"....)

#Statistical Analysis

#Appendix

##Vectors

Vectors are the fundamental data type in R and are composed of an ordered group of single items of data.  There are several ways to construct a vector, but perhaps the simplest and most commonly used is `c()` function. This may seem like an unintuative name (you'll get used to some of R's idosyncracies if you use it long enough), but it stands for *concatonate* as what the function is actually doing is sticking together a number of smaller objects.

```{r}
numericVector <- c(1, 2, 3, 4)
```

When you create a variable with a single value, you are still creating a vector - it just has a length of one.  This is why we can describe vectors as the fundamental data type in R, there is nothing smaller to break them down into.

```{r}
shortVariable <- 1
shortVariable
shortVariable[1]
```

Vectors don't have to contain numbers, they work equally well for storing character data.

```{r}
characterVector <- c("one", "two", "three", "four")
```

One important thing to note is the all the values in a vector must be of the same type.  For instance you cannot have numeric and character data in the same vector.  However R won't neccessarily report and error if you try to do this, as the example below shows:

```{r}
mixedVector <- c(1, 2, "three", "four")
mixedVector
```

You can see in the output that all four values have quotation marks around them.  This indicates that R has automatically converted the numeric value to character strings.  If you wanted to keep the distinct data types you may wish to use a data frame, which we'll discuss in the next section.

##Data Frames

If we want to store multiple types of data in a single object with the row and column structure you might expect from a spreadsheet or printed table, we need to use a new object type: the *data frame*.  In the example below we'll create a data frame using two of the vectors created in the previous section.

```{r}
 charNumFrame <- data.frame(numericVector, characterVector)
 charNumFrame
```

##Factors

##Subsetting

Sometimes you only want to use a subset of the data stored in an object; perhaps you only want the first five items from a long vector, or you're only interested in the second column from a data frame.  To extract a portion of an object we need to use R subsetting functionality, which is denoted by square brackets `[]`.

```{r}
 characterVector[2:3]
 charNumFrame[3:4, ]
```

In the example above the first line extracts the 2nd and 3rd entries from a vector, while the second line selects rows 3 and 4 from a data frame.  If we wanted to obtain the same rows, but only for the first column we'd need to specify that too:

```{r}
 charNumFrame[3:4, 1]
```

There are a couple of things to note here. Firstly, when dealing with a data frame even if you want all the columns you still need to put the comma `,` in the subset command - otherwise you'll get an error as below.  

Secondly, if you're really paying attention to the example above you'll notice that when we only select one column the format the data is printed to screen in changes. The entries are now next to each other rather than on top of one another. This is because when you only select one column R automatically gives you back a vector rather than a data frame.  This behaviour can sometimes be useful and sometimes frustrating, but if you want to ensure it doesn't happen you can use the `drop=FALSE` argument seen below.

```{r}
 charNumFrame[3:4]
 charNumFrame[3:4, 1, drop=FALSE]
```

##Functions

##Useful functions to know

##R version details

The version of R and the packages used in this document are given below.


```{r}
sessionInfo()
```

