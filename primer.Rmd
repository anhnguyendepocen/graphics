---
title: 'Data  Manipulation and Visualisation: An R primer'
author: "Mark Dunning and Mike Smith"
date: "09/09/2014"
output:
  html_document:
    toc: yes
    toc_depth: 3
  pdf_document:
    toc: yes
---

#Introduction

This document will guide you through the key concepts and techniques required to manipulate and process data in R. It is intended to be a reference document that you can refer to when you need to perform a particular task in R. 

1. Read the data into R
  + What format are the data in? 
2. Manipulate the data
  + What columns / rows are needed for the analysis? Do any additional calculations need to be performed?
3. Plot the data
  + What type of plot do you need to convey your message? What type of data do you need for the plot
  
#Recommended references

Much [freely-available](http://cran.r-project.org/other-docs.html) documentation about R is available from CRAN. In particular, the R [reference card](http://cran.r-project.org/doc/contrib/Short-refcard.pdf) is recommended. 

There is no shortage of other R tutorials available online. Some that have provided particular inspiration in the construction of this document are listed below:

- [R cookbook](http://www.cookbook-r.com/)
- [Quick-R](http://www.statmethods.net/)
- [UC Riverside R & Bioconductor manual](http://manuals.bioinformatics.ucr.edu/home/R_BioCondManual)

#Running R and RStudio

Our recommended way of using R is via the RStudio interface. Like R, this software is freely to download and available on any operating system. You will need to download the latest versions of R and RStudio.

##Installing R

Download links for R can be found on the [CRAN](http://cran.r-project.org/) page (Comprehensive R Archive Network). There are separate downloads for [Windows](http://cran.r-project.org/bin/windows/base/R-3.1.1-win.exe) and [Mac OSX](http://cran.r-project.org/bin/macosx/R-3.1.1-snowleopard.pkg). Unix, or advanced users will need to find the appropriate link to their distribuion, or consider downloading the [source code](http://cran.r-project.org/src/base/R-3/R-3.1.1.tar.gz). 

##Installing RStudio

RStudio was created by a third-party company and available as a free download. You can find an *installer* for your platform on the [download](http://www.rstudio.com/products/rstudio/download/) page. Make sure that you are downloading the **Desktop** version of RStudio, rather than the *server* version.

##About this document

This document was written in RStudio using the **markdown** format. If you see a section like this, you can copy-and-paste the text into RStudio and execute it. 
 
```{r eval=FALSE}
print("Hello World")
```


Often the output from R will be displayed after the R command. You can compare this to the output that you get from running the command yourself.

```{r}
print("Hello World")
```

Sometimes the graphics produced by R will be displayed too.

```{r}
plot(runif(1:10))
```

#Reading data into R

The first stage of doing an analysis in R is to import some raw data that is presented a *spreadsheet-like* format. By which we mean data organised in rows and columns like we usually see in a spreadsheet program such a Microsoft Excel.

Unfortunately, importing data can be the source of many errors and frustrations; sometimes halting an analysis before it has even begun. *Well-formatted* data should be easy to read using a small selection of functions, although the user will have to decide which function to use. The key first steps are to locate the relevant raw data file on your hard drive and decide what format it is in. As a *rule-of-thumb*, [tab-delimited](#tab-delimited-file) files have file extensions *.txt* or *.tsv*, whereas [comma-separated](#comma-separated-file) have an extension *.csv* .

More information on reading files into R can be found online at the [R data manual](http://cran.r-project.org/doc/manuals/R-data.html) or [an introduction to data cleaning with R](http://cran.r-project.org/doc/contrib/de_Jonge+van_der_Loo-Introduction_to_data_cleaning_with_R.pdf)

##Specify a path to the file

R needs to know where the file is located on your hard drive in order to read it. If the file is located within your *working directory* then you can just specify the name of the file. You can find out the location of your working directory using the `getwd` function.

```{r eval=FALSE}
getwd()
```

You can also interrogate the contents of your working directory using the `dir` function

```{r eval=FALSE}
dir()
```
The `dir` function has a useful argument `pattern` which will list files that contain a particular *string* of text. For instance, we can list all files of type `.csv` and `.txt` in the current working directory that could potentially be read into R.

```{r eval=FALSE}
dir(pattern=".csv")
dir(pattern=".txt")
```

If the file you want to read is not in your working directory, then you will need to specify thepath to the file. A useful function in this situation is `file.choose`, which will open a dialog box allowing you to navigate to the file. The location can be stored as a variable.

```{r eval=FALSE}
myfile <- file.choose()
```

When specifying the file location manually, it has to giving within *quote marks*, as in the following example


```{r}
myfile <- "PrimerExamples/Indepentent two-sample t-test_v2_long.txt"
```

We will now discuss various ways of loading tabular data into R. The examples should cover most file types that you might encounter (e.g. csv, txt, tsv, xlsx files). If you have an example file that doesn't seem to fit any of these example, please let us know. Please note that R is not able to import GraphPad Prism files, as this file format is proprietary. You will have to use a commercial version of Prism to export the data table into a text-file. 

Once a file has been read into R, we recommend that you **check the dimensions and contents**. Sometimes R will read a file without error, but may not have been able to interpret the structure of the data correctly, which will cause problems for further analysis.

##What separator should be used?

```{r}
count.fields("PrimerExamples/Indepentent two-sample t-test_v2_long.txt",sep="\t")
count.fields("PrimerExamples/Indepentent two-sample t-test_v2_long.txt",sep=",")

```


##Tab-delimited file

As a *rule-of-thumb*, tab-delimited files have file extensions *.txt* or *.tsv*. If your file is tab-delimited and you have specified the location using the previous section, you will be able to use the `read.delim` function. The `file.exists` is a useful function for checking that the file location is correct; returning `TRUE` if so.

```{r}
myfile <- "PrimerExamples/Indepentent two-sample t-test_v2_long.txt"
file.exists(myfile)
mydata <- read.delim(myfile)
```

Assuming that the function does not produce an error, you should now have a variable `mydata` in your R workspace. This is *data frame* object, described in more detail in the [appendix](#data-frames). At this point, it is highly recommended that you check the contents of the variable. The `View` command should open a new tab in RStudio.

```{r eval=FALSE}
View(mydata)
```

The dimensions and structure of the data can be further interrogated using the following [useful functions](#useful-functions-to-know).

```{r}
dim(mydata)
str(mydata)
head(mydata)
```

In this case, the object has `r ncol(mydata)` columns and `r nrow(mydata)` rows; as we would expect.

Now notice what happens if we read the file by (incorrectly) calling the `read.csv` function on a *tab-delimited* file

```{r}
myfile <- "PrimerExamples/Indepentent two-sample t-test_v2_long.txt"
mydata <- read.csv(myfile)
dim(mydata)
str(mydata)
head(mydata)
```

R was able to read the file without error, but the dimensions of the resulting object are incorrect. In particular, it has been unable to separate the columns because an incorrect s
eparator was used (a `,` rather than a tab). 

##Comma-separated file

Files that have columns separated by commas can be read using the `read.csv` function. The file location needs to be specified by either using the `file.choose` function as follows;

```{r eval=FALSE}
myfile <- file.choose()
```

Or by specifying the path to the file within quote marks. Once the file has been read, we check the dimensions and general structure.

```{r}
myfile <- "PrimerExamples/One-sample t-test.csv"
mydata <- read.csv(myfile)

dim(mydata)
str(mydata)
head(mydata)
```


##Excel file

R is even able to read Excel spreadsheets. This requires an additional *package* to be installed; `gdata`. This package is loaded as follows;

```{r}
library(gdata)
```

It is not uncommon for a package to print text to the screen upon loading. You should not mistake this text for an *error* message.

However, if you do not have `gdata` installed you will get an error message in the following form.

```{r echo=FALSE,warning=FALSE}

error <- try(library(foo),silent = TRUE)
message(gsub("foo", "gdata",error[1]))
```

If this error occurs, the package will need to be installed and then loaded
```{r,eval=FALSE}
install.packages("gdata")
library(gdata)
```

Note that you will only need to install the package once for a particular R *version*. However, you will need to load this library in every new R session when you require the functionality to read Excel files.

We can now call the `read.xls` function from `gdata` to create a *data frame* from your input file.

```{r}
myfile <- "PrimerExamples//Indepentent two-sample t-test_v2_long.xlsx"

mydata <- read.xls(myfile)
dim(mydata)
head(mydata)
```

##Specifying a different separator

If your file is neither `tab` or `comma` separated, then `read.csv` and `read.delim` will not be able to read the file correctly with their default arguments. In the following example, we try and use to `read.csv` on a file with columns that are separated with a space (`" "`).

```{r}
myfile <- "PrimerExamples/space-separated.csv"
mydata <- read.csv(myfile)
dim(mydata)
head(mydata)
```

We see that the dimensions of the data object are incorrect. Both `read.csv` and `read.delim` have the option to specify a different separator. 

```{r}
mydata <- read.csv(myfile, sep=" ")
dim(mydata)
head(mydata)
```


##SPSS file
R is able to read data created by SPSS. This requires an additional *package* to be loaded; `foreign`.

```{r}
library(foreign)
```

You only need to load the library *once* per R-session. We can now call the `read.spss` function from `foreign` to create a *data frame* from your input file.

```{r}
myfile <- "PrimerExamples/p004.sav"

mydata <- read.spss(myfile,to.data.frame = TRUE)
dim(mydata)
head(mydata)
```

The `foreign` package is also able to read files in `SAS` (`read.export`) and `STATA` (`read.dta`) formats, but sadly not Graphpad Prism.

##Further options for reading files
Sometimes we might be faced with 'messy' data that do not have a straightforward format of rows and columns. 
`read.csv` and `read.delim` are in fact specialised versions of a generic `read.table` function. This function has many options to allow finer-grain control over how files are read into R, as you will see from the manual page. 

```{r eval=FALSE}
?read.table
```

We now summarise the options that prove to be most useful

###Skipping lines

By default, R will assume that your data table starts on the first line of the file and that the column headers are found on the first line. However, sometimes the data table can be preceeded with several lines of header information. The header may contain useful information for the user, such as the date the file was generated and software versions etc, but is not relevant when we try and read the data table into R. 

If we try and use the default settings of `read.delim` to read a tab-delimited file with arbitrary header information, the following occurs. In this case, the file contains counts for a number of barcodes deteceted on a particular lane of sequencing. Naturally, we might want to read these data into R and perform some exploratory analysis and diagnostics.

```{r}
myfile <- "PrimerExamples/file-with-header.txt"
mydata <- read.delim(myfile)
head(mydata)
```

You will notice that R has tried to interpret the header information as lines of the data table, and therfore the data is not imported correctly.

Fortunately, both `read.csv` and `read.delim` have a `skip` argument so that we can start reading the data table from a pre-determined position in the file. In this example we have to *skip* the first 11 lines of the file in order to reach the table.

```{r}
mydata <- read.delim(myfile, skip=11)
head(mydata)
```

In practice, you may have to try different values for the `skip` argument in order to obtain the correct result. Use of the `head` and `dim` functions should help you determine when the data has been read correctly.

###Files with no header

Conversely, sometimes files can be created without any column names. By default, R assumes that the first row in the file contains column headings. This can have unexpected consequences when a file does not contain column headings. 


```{r}
myfile <- "PrimerExamples/file-with-no-header.csv"
mydata <- read.csv(myfile)
head(mydata)
dim(mydata)
colnames(mydata)
```

In this example, R took the first line of the file to be the column headings and so we have column names `r paste(colnames(mydata),collapse=" & ")`. Moreover, the data frame produced has `r nrow(mydata)` rows rather than `r nrow(mydata)+1`. The remedy is to set the `header` argument to `FALSE`. Both `read.csv` and `read.delim` are able to recognise the `header` argument.

```{r}
myfile <- "PrimerExamples/file-with-no-header.csv"
mydata <- read.csv(myfile,header=FALSE)
head(mydata)
dim(mydata)
colnames(mydata)
```

You can modify the column names of the `mydata` object.

```{r}
colnames(mydata) <- c("Month", "Value")
```


###Reading a pre-determined number of lines

It is possible to read only a fixed number of rows by using the `nrows` argument. Useful if you just want to see the first few lines in a file.

```{r}
subset <- read.csv("PrimerExamples/One-sample t-test.csv",nrows=4)
subset
```



###Invalid characters

Consider the following file, which we are told has the expression levels of 20 genes. We use `read.delim` to read the file (as it is tab-delimited)

```{r}
myfile <- "PrimerExamples/DiffGenes.tsv"
mydata <- read.delim(myfile)
head(mydata)
dim(mydata)
```

However, the number of rows comes out as `r nrow(mydata)`. We can use the `tail` function (analagous to `head`) to look at the last few rows in the file.

```{r}
tail(mydata)
```

Problems of this nature are usually due to an extraneous quotation mark `"` or `'` being found somewhere in the file. We can tell `read.delim` to ignore quotation marks in the following way. Of course, we could have editted the raw data to remove the quote mark, but this might not be practical for larger files.

```{r}
mydata <- read.delim(myfile,quote = "")
```

We now look at a second example file, which upon first impressions loads without any problems.

```{r}
myfile <- "PrimerExamples/DiffGenes2.tsv"
mydata <- read.delim("PrimerExamples/DiffGenes2.tsv",header=FALSE)
head(mydata)
dim(mydata)
```
A natural data exploration step would be to calculate the mean of the gene expression values, which are stored in the second column. However, we cannot do this even if we tell R to ignore any `NA` values. We can discover that the second has not been treated as numeric values by R.

```{r}
mean(mydata[,2])
mean(mydata[,2],na.rm=TRUE)
summary(mydata[,2])
str(mydata)
```

The issue is that our collaborator has chosen to use a `?` to denote a missing value in the second column. This causes R to think that this column contains characters rather than numbers. A solution is to use the `na.strings` argument to specify a particular value that is used to denote a missing value.

```{r}
myfile <- "PrimerExamples/DiffGenes2.tsv"
mydata <- read.delim("PrimerExamples/DiffGenes2.tsv",header=FALSE,na.strings="?")

head(mydata)
str(mydata)
summary(mydata[,2])
mean(mydata[,2],na.rm=TRUE)
```



###If all else fails...

The `readLines` function can be used. This is a *low-level* function for reading data into R and reads each line in the file as avector, along with the characters used to separate the columns. For example, if we read a file with a `.txt` extension.

```{r}
temp <- readLines("PrimerExamples/Indepentent two-sample t-test_v2_long.txt")
head(temp)
```

The fact that a `\t` character can be seen in each item of the vector tells us that we should be using the `read.delim` function. Likewise, with a `.csv`

```{r}
temp <- readLines("PrimerExamples/One-sample t-test.csv")
head(temp)
```
each item in the vector has a `,` character which is used to separate the data into two columns. We should read this file using `read.csv`

If we have a file with `header` information, we can use `readLines` to identify the line on which the data table begins, and hence what we should use as a `skip` argument.

```{r}
temp <- readLines("PrimerExamples/file-with-header.txt")
temp[1:15]
```
In this case, we can see the column headings for the data table start on line 12. Thus, we should read the file with `skip=11` in the function `read.delim`.


##Strings as factors

R is primarily a statistics language so much of its functionality is geared-up to make things ameanable to statistical analysis. For instance, it will prefer to work with [Factors](#factors) rather than characters. When a data table is read into R, as stored as a data frame, the default behaviour is to store character [vectors](#vectors) as factors. This may not always be neccesary. 

```{r}
myfile <- "PrimerExamples/One-sample t-test.csv"
mydata <- read.csv(myfile)
str(mydata)
```

We do not plan to take advantage of this behaviour and can easily work with the months in character form. Therefore we can set the argument `stringsAsFactors=FALSE`

```{r}
myfile <- "PrimerExamples/One-sample t-test.csv"
mydata <- read.csv(myfile,stringsAsFactors=FALSE)
str(mydata)
```



##Data in multiple files

If the dataset you want to import is spread over several data files, you will have to read each file individually and combine the respective data frames into a single object. 

##Data from online sources

The `repmis` package (misellaneous tools for reproducible research) contains useful functions to retrieve online data. 

```{r eval=FALSE}
install.packages("repmis")
```

A useful resource for such data is the Github page of [Vincent Arel-Bundock](http://vincentarelbundock.github.io/Rdatasets/datasets.html), which has csv version of example datasets found in many R packages. We can download data from this page using the `source_data` function. For example, if we browse the web page we can see there is an dataset containing Ovarian Cancer survival data. We can copy the URL of the corresponding `.csv` file and paste into R.

```{r eval=FALSE}
library(repmis)
surv <- source_data("http://vincentarelbundock.github.io/Rdatasets/csv/survival/ovarian.csv")
head(surv)
```


#Using pre-built datasets

R comes with the `datasets` package which contains many example datasets ready for exploration and analysis. To see what datasets are available, along with brief descriptions, enter the following;

```{r eval=FALSE}
data()
```

If you see a dataset that might be interesting (e.g. the `DNase` dataset which measures the density of a protein at various concentrations), it can be loaded into R in the following manner. 

```{r}
data(DNase)
head(DNase)
```
Further details on the dataset can be found on its help page.
```{r eval=FALSE}
?DNase
```


```{r echo=FALSE}
par(ask=FALSE)
```

Moreover, example plots and code can be generated using the `example` function.

```{r}
example(DNase)
```

#Data manipulation

The term *data manipulation* is used here to describe the steps that occur after having [read data into R](#reading-data-into-r) and prior to [plotting](#plotting) and/or [statistical analysis](#statistical-analysis).

##Selecting columns from a data frame

We will illustrate using the `mtcars` data, one of the in-built datasets in R. We can load the data using the `data` function and query the dimensions and print the first few lines using `dim` and `head`. 

Subsetting in R **always** uses the `[row,column]` notation.

###By column number

```{r}
data(mtcars)
head(mtcars)
dim(mtcars)
```

Columns in the data frame can be retrived using a numeric index. The *first* column can be retrieved by specifying the *column* as 1 in `[row,column]` notation. However, we if we want values for all observations (rows) we can neglect to specify a value before the `,`. e.g.


```{r}
mtcars[,1]
```

The output is a [vector](#vectors) and it's length will be the same as the number of rows in the data frame. Note that we have not altered the `mtcars` data frame in any way. It will still have the same number of columns. 

```{r}
dim(mtcars)
```

If we want to do some further calculations on the vector we have extracted, we need to assign it to a variable

```{r}
myvector <- mtcars[,1]
length(myvector)
myvector
```


The notation is very similar to retrieve the second column

```{r}
myvector <- mtcars[,2]
length(myvector)
myvector
```

If we want to retrieve the first and second columns *at the same time*, we can construct a [vector](*vectors), using the `c` function, comprising the indices we want to retrive and use this in the `[]` notation. The result is a *data frame* itself.

```{r}
mydf <- mtcars[,c(1,2)]
head(mydf)
dim(mydf)
```

We can also use the `:` shortcut to generate a sequence of consecutive integers

```{r}
mydf <- mtcars[,c(1:3)]
head(mydf)
dim(mydf)
```

###By column name (Recommended)

We can also extract data using the names of columns. This is the recommended approach, as you might not be sure that the same variables will *always* be stored in the same column. 


```{r}
myvec <- mtcars[,"mpg"]
head(myvec)
```

The column names can be combined using the `c` function
```{r}
mydf <- mtcars[,c("mpg","cyl")]
head(mydf)
```

We can also access columns by name using the `$` operator. By default, this will return all values in the column. This approach can be used in conjunction with *tab-completion*; meaning that you start typing the name of the column and press the `TAB` key. A list of possible column names will then appear.

```{r}
myvec <- mtcars$mpg
myvec
```



##Row subsetting

###Subset rows by index

If we know the index of the row we want to retrieve, we can supply these indices in the `[]` notation. The get the first row, we can do

```{r}
mtcars[1,]
```

Muliple rows can be specified at a time. For example using the `:` shortcut

```{r}
mtcars[1:5,]
```

###Logical indexing

The term `logical` is used to describe values that are either `TRUE` or `FALSE` (sometimes called `Boolean` values in other languages). We can combine logical values into a [vector](#vectors) and use for subsetting. In particular, they can be used to specify exactly which elements we extract from a vector. In this example, we create a vector of length 10, and another `logical` vector of the same length. Using the logical vector within the square brackets `[]` will tell R to extract elements *only* when the corresponding value in the the logical vector is `TRUE`

```{r}
myvec <- 1:10
myvec
logvec <- c(TRUE,TRUE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,FALSE,TRUE)
logvec
myvec[logvec]

```

In this case, `logvec` has `TRUE` values in positions `r paste(which(logvec),collapse=",")`. So these are the elements of `myvec` that can extracted in `myvec[logvec]`.

There are several arithmetic operations that perform comparisons and produce a logical vector as output. The most common of these are  `>,<,==`. Where `==` is used to test that two numerical values are the same.

If we wanted to restrict the data frame to rows where the `mpg` is less than `15`, we would first create a vector that will test all values of `mpg` to see if they are less than 15. Notice that the vector created is the same length as the number of rows in the data frame (`r nrow(mtcars)`).

```{r}
myind <- mtcars$mpg < 15
myind
length(myind)
```

The logical vector, can now be used to subset the data frame. Only rows where `myind` has a value of `TRUE` will be returned.

```{r}
mtcars[myind,]
```

Note that in the previous command we have created a *subset* of the data frame and not altered the original object; the number of rows is still `r nrow(mtcars)`

```{r}
subset <- mtcars[myind,]
subset
dim(subset)
dim(mtcars)
```


Logical vectors can be used in combination, provided they are the same length. Now if we wanted all cars with `mpg < 15` *and* `drat > 3` we can combine the two conditions using the `&` operation.

```{r}
myind <- mtcars$mpg < 15 & mtcars$drat > 3
myind
length(myind)
```

Notice that `myind` is still length `r nrow(mtcars)`. 

```{r}
subset <- mtcars[myind,]
subset

```

Other ways of combining logical vectors include `|` (*or*) and `!` (*negation*).

###%in%
A common task in exploratory data analysis is to ask whether a specific value or values exists in a larger R object.  For example you may want to know whether a specific gene name appears in a long list of names you've just read in.  To achieve this we can use the `%in%` command. Note that we have to specify each gene name within quotation marks `""`. 

```{r eval=TRUE}
"BRCA1" %in% c("RAS", "MYC", "BRCA1", "TP53")
```

In the case above we were only interested in a single text query.  The example below demonstrates both that `%in%` is equally happy working with numeric values, and that a [vector](#vectors) of queries can be used in a single command.  Here a vector of `TRUE` or `FALSE` values the same length as the number of queries will be returned. This is far more efficient that trying each in turn.

```{r eval=TRUE}
c(1,5,11) %in% 1:10
```

In our particular example, we could restrict the analysis to just rows that correspond to particular cars. The car names appear in the `rownames` of the data frame. 

```{r}
rownames(mtcars)
myInd <- rownames(mtcars) %in% c("Merc 230", "Merc 280")
myInd
mtcars[myInd,]
```

`myInd` is a *logical* [vector](#vectors) (i.e. either `TRUE` or `FALSE`) of length `r nrow(mtcars)`, where each denotes whether that particular rownames is one of the supplied vector. This logical vector can then be used to subset the data frame.

###match,

While the `%in%` command is useful for telling you whether a query appears somewhere, it doesn't specify where in the subject you will find it.  However there are several ways to achieve just this, where perhaps the most straightforward is `which()`.

```{r eval=TRUE}
which(c("RAS", "MYC", "BRCA1", "TP53") == "BRCA1")
```

However this approach falls down if one is interested in multiple queries.
```{r eval=TRUE}
which(c("RAS", "MYC", "BRCA1", "TP53") == c("BRCA1", "RAS"))
```
To avoid the confusion this could cause, it is better the employ the function `match()`


```{r eval=TRUE}
match(x = c("BRCA1", "MYC"), table = c("RAS", "MYC", "BRCA1", "TP53"))
```

If we just wanted to find which row corresponds to `Merc 230` we can use the `match` function to see the index of  the `rownames(mtcars)` vector that corresponds to the *string* `"Merc 230"`.

```{r}
myInd <- match("Merc 230", rownames(mtcars))
myInd
mtcars[myInd,]
```

However, we have to remember that `match` will only return the index of the *first* occurence. If the string we want to find occurs multiple times, then we may get unexpected results further on in the analysis. Also, the text has to *exactly* match. Sometimes it is safer to use the `grep` function.

###grep 

`grep` will return *all* rownames that contain the string `Merc` *somewhere* in their name we can use the `grep` function.

```{r}
myInd <- grep("Merc", rownames(mtcars))
myInd
mtcars[myInd,]
```


##Adding new columns / variables

##Re-ordering data frames


```{r}
order(mtcars[,"mpg"])
mtcars[order(mtcars[,"mpg"]),]
```

```{r}
order(mtcars[,"mpg"],decreasing=TRUE)
mtcars[order(mtcars[,"mpg"],decreasing=TRUE),]
```

```{r}
sort(rownames(mtcars))
sort(mtcars[,"mpg"])
```

##Transpose a matrix

```{r}
mydata <- read.csv("PrimerExamples/Paired two-sample t-test.csv")
dim(mydata)
mydata.t <- t(mydata)
mydata.t
```




##Text manipulation

###nchar

```{r}
nchar(rownames(mtcars))
```

###toupper

```{r}
toupper(rownames(mtcars))
```


###gsub

###strsplit

```{r}
tmp <- strsplit(rownames(mtcars)," ")
```


###substr

```{r}
substr(rownames(mtcars), 1,4)
```

###paste

```{r}
paste("Hello", "World")
```

```{r}
paste("Month", 1:12, "is",month.name)
```

##Long versus wide format

##Calculating summary statistics

##apply, tapply, aggregate

#Writing data to a file

#Plotting

A plot can be created in R simply by calling the `plot` function with a valid R object. However, there are many optional arguments can be altered to change the apperance of the plots; from the title, labels, colour and shapes used to plot, 


###A histogram

The `hist` function requires a *numeric* vector, which could be the result of some calculation you or have performed or the column from a data frame. In this example, we will read an example file

```{r}
mydata <- read.csv("PrimerExamples/One-sample t-test.csv")
mydata

```

The data concern (fictional) failure rates for microarrays in Genomics. To visualise the distribution of the failure rates, we could use a histogram using the `hist` function. We have to [select the relevant column](#selecting-columns-from-a-data-frame) from the data frame, in this case the second column. 


```{r}
hist(mydata$Failure.rate)
```

Unfortunately, the default plot that R creates is not that pretty. As with all plotting functions, there is a [large amount of customisations](#changing-the-plot-appearance) that are possible. Details are on the *help* page for `hist`.

```{r eval=FALSE}
?hist
```


We can specify an [alternative colour](#specifying-colours) using the `col` argument.

```{r}
hist(mydata[,2],col="steelblue")
```

And add more informative labels and titles using `main` and `xlab`

```{r}
hist(mydata[,2],col="steelblue",main="Microarray Failure Rates",xlab="Rate")

```

Technical modifications include displaying frequencies on the y-axis rather than counts.

```{r}
hist(mydata[,2],col="steelblue",main="Microarray Failure Rates",xlab="Rate",freq =  FALSE)

```

We can also specify the number of *breaks*

```{r}
hist(mydata[,2],col="steelblue",main="Microarray Failure Rates",xlab="Rate",freq =  FALSE,breaks = 12)

```


###A scatter plot

The `plot` function is the generic function for plotting in R, and can produce different plots depending on the input. A scatter plot can be generated by specifying a *vector* to go along the x-axis, and a *vector* for the y axis. It is assumed that the first argument supplied is for the x axis, and the second for the y -axis.

```{r}
mydata <- read.delim("PrimerExamples/Linear regression.txt")
mydata
plot(mydata[,1],mydata[,2])
```

We can in fact just specify one vector, in which case the x axis is assumed to be the *index* of vector. 

```{r}
plot(mydata[,2])
```

By default, a open circle is drawn at each x and y combination. If we wish, we can draw a *line* through the points by using the argument `type="l"`

```{r}
plot(mydata[,2],type="l")
```

Or choose to have both a line and the points by specifying `type="b"`

```{r}
plot(mydata[,2],type="b")
```

Later on, we will show how to add extra lines and points to this basic plot

###A bar plot

```{r}
mydata <- read.csv("PrimerExamples/One-sample t-test.csv")
mydata
barplot(mydata[,2])

```

```{r}
rownames(mydata) <- mydata[,1]
barplot(mydata[,2])
```


###A boxplot

```{r}
mydata <- read.csv("PrimerExamples/Paired two-sample t-test.csv")
mydata
boxplot(mydata)
```




##Exporting a plot

R is able to save graphics in a variety of formats. The easiest way of saving a plot is to use the *Export* tab in the plot window in RStudio. You will then have the option of saving the plot as a *.pdf* or a variety of other file formats such as *.jpeg*, *.png*, *.tif*.

N.B. *.pdf* plots can be futher altered in a graphics program such as *Photoshop*, whereas *.jpeg*, *.png* can be more easily inserted into presentations. Journals often require high-resolution images in *.tiff* or *.eps* format.

The lines of code required to save a plot to a file are almost identical to producing the plot within RStudio; the only difference is that you need to send the the plot to an alternative *graphics device* other than RStudio, and close the device afterwards. 

There are various functions can be used to create an alternative graphics device. These include `pdf`, `jpeg`, `png` and have to be called before the code that creates the plot. You have to specify a file name that the plot will be written to. However, the file does not have to exist prior to creating the plot.

In the following example, we will save a boxplot as a *.png* file. We will therefore use the `png` function to write the plot to a file. If you run the code, you will notice that the plot is no longer displayed in RStudio. This is because the plot has been created in an alternative graphics *device*. We therefore have to use the `dev.off` function to close this device and allow us to open the file.

```{r echo=FALSE, results='hide'}
if(file.exists("myboxplot.png")) file.remove("myboxplot.png")
```


```{r}
mydata <- read.csv("PrimerExamples/Paired two-sample t-test.csv")
file.exists("myboxplot.png")
list.files(pattern=".png")
png("myboxplot.png")
boxplot(mydata)
dev.off()


```

You should notice that a file `myboxplot.png` has been created in your working directory. We can verify this using the `file.exists` and `list.files` functions.

```{r}
file.exists("myboxplot.png")
list.files(pattern=".png")
```

To create a *.jpeg* instead of a *.png*, we simply use `jpeg` instead of `png`.

```{r}
jpeg("myboxplot.jpeg")
boxplot(mydata)
dev.off()
```

You can specify the height and width of the plot by adjusting the `height` and `width` arguments. This can be done in the same way for the `jpeg` and `png` functions. The values for `height` and `width` should be the required number of pixels. 


```{r}
jpeg("myboxplot2.jpeg",width=800,height=500)
boxplot(mydata)
dev.off()
```


*.pdf* documents as created in much the same way using the `pdf` function. However, you should note that the dimensions of the plot are specified in *inches* rather than *pixels*.

```{r}
pdf("myboxplot.pdf",width=8,height=4)
boxplot(mydata)
dev.off()
```

An important different between *.jpeg*, *.png* and *.pdf* is that *.pdf* documents can have multiple pages. In the following example, we have multiple lines of code between the `pdf` and `dev.off` lines. Each plot is saved onto a separate page in the pdf document.

```{r}
pdf("myplots.pdf")
hist(mydata[,1])
hist(mydata[,2])
boxplot(mydata)
dev.off()
```


##Changing the plot appearance




###Titles and axis labels

It is always a good idea to use informative titles and axis labels on your plots. Unfortunately, the default plots produced by R try and *guess* labels from the data, which may not be that useful. The `plot` function has `main`, `ylab` and `xlab` arguments that can be used to specify these labels (which must be a character vector). Moreover, other plotting functions such as `boxplot`, `barplot` and `histogram` also use the same argument names. 

```{r}
mydata <- read.delim("PrimerExamples/Linear regression.txt")
plot(mydata[,1],mydata[,2],main="My Title", xlab="X axis", ylab="Y axis")
```


###Specifying Colours

The simplest way of specifying a colour in R is to use a pre-defined character string. There are `r length(colors())` preset values you can use, which can be printed to the screen using the `colors` function.

```{r eval=FALSE}
colors()
```

There is a [colour chart](http://www.stat.columbia.edu/~tzheng/files/Rcolor.pdf) available online that can be used to display the colors alongside the names.

**You should make sure that the colour scheme that you choose is suitable for those with colour-blindness**. e.g. avoiding red / green colour schemes. One way of ensuring this is to use predfined pallettes in the `RColorBrewer` package. 

```{r fig.height=10,fig.width=10}
library(RColorBrewer)
display.brewer.all()
```

```{r}
mypal <- brewer.pal(8, "Set1")
mydata <- read.csv("PrimerExamples/Paired two-sample t-test.csv")
plot(mydata[,1],col=mypal)
```

If you wish to use Cancer Research Uk or Cambridge University branding, you can use the colours defined in the `crukCIMisc` package. This package includes a function, `CRUKcol` which can be used to generate the Cancer Research UK blue or pink colours.


```{r}
library(crukCIMisc)
plot(mydata[,1], col=CRUKcol("Blue"),pch=16)
points(mydata[,2],col=CRUKcol("Pink"),pch=16)

```

```{r}
boxplot(mydata, col=c(CRUKcol("Blue"),CRUKcol("Pink")))
```

###Plotting characters and their values

```{r echo=FALSE}
par(mar=c(0.1,0.1,0.1,0.1))
i <- 0:24

x <- floor(i /5) + 1
y <- i %%5

plot(1:10, type="n", xlim = c(1,5), ylim=c(-1,5),axes=F,xlab="",ylab="")
points(x,y,pch=i+1)
text(x,y-0.3,i+1)

```

We can specify a new plotting character using the `pch` argument. For example `pch=16` uses filled rather than open circles.

```{r}
mydata <- read.csv("PrimerExamples/Paired two-sample t-test.csv")
plot(mydata[,1],pch=16)

```

Rather than being a single value, `pch` can be a vector of values

```{r}
mydata <- read.csv("PrimerExamples/Paired two-sample t-test.csv")
plot(mydata[,1],pch=1:nrow(mydata))

```


###Adding lines, text, points to a plot

Once a plot has been created, we have various options to modify it. Firstly we can add vertical and horzontal lines to the plot using `abline` (read as *ab line*) with the `v` and `h` arguments respectively. Here we construct a scatter plot as before, and 



```{r}
plot(mydata[,1],pch=1:nrow(mydata))
abline(h=1300)
abline(v=10)
```

The appearance of the line can be modified, for example to be [coloured differently](#specifying-colours).

```{r}
plot(mydata[,1],pch=1:nrow(mydata))
abline(h=1000,col="steelblue")
abline(v=5,col="orange")

```

A dotted line be drawn by specifying `lty=2` and the width can be changed using the `lwd` argument.

```{r}
plot(mydata[,1],pch=1:nrow(mydata))
abline(h=1000,col="steelblue",lty=2,lwd=5)
abline(v=5,col="orange",lty=3,lwd=10)

```

Another use for the `abline` function is to specify an intercept and coefficient for the line (the *a* and *b* in the `abline` name). For instance, if we wanted the line corresponding to equality of two vectors, *y = x*, we can say.

```{r}
mydata <- read.csv("PrimerExamples/Paired two-sample t-test.csv")
plot(mydata[,1],mydata[,2])
abline(a=0,b=1)
```

The `points` function can be used to add points to an existing plot. You need to specify vectors of *x* and *y* positions at which the points will be plotted.


```{r}
data <- read.delim("PrimerExamples/Linear regression.txt")
plot(data[,1],data[,2])
points(data[,1],data[,3])
```

We can [modify the colours](#specifying-colours) in which points are plotted. 

```{r}
plot(data[,1],data[,2],col="steelblue")
points(data[,1],data[,3],col="orange")

```

Or change the [plotting characters](#plotting-characters-and-their-values)

```{r}
plot(data[,1],data[,2],col="steelblue",pch=16)
points(data[,1],data[,3],col="orange",pch=17)
```


`text` adds text to an existing plot

```{r}
plot(data[,1],data[,2],col="steelblue",pch=16)
points(data[,1],data[,3],col="orange",pch=17)
text(data[,1],data[,3],labels=LETTERS[1:10])
```

The `arrows` function can be used to connect pairs of points on an existing plot. We have to supply *start* ane *end* x and y coordinates. In the example below, we draw and arrow from *(2,1.5)* to *(10,4)*.

```{r}
plot(data[,2])
arrows(2, 1.5, 10, 4)
```


Customisations of the arrow are possible and multiple arrows can be drawn by supplying the coordinates as vectors. See the help page for more information.


```{r eval=FALSE}
?arrows
```


This function may not seem very useful initially, but it can be used as a means of drawing *error bars* on a plot. 

```{r}
randMat <- matrix(rnorm(100),ncol=10)

means <- colMeans(randMat)
plot(means,ylim=c(-2,2))

err <- apply(randMat, 1, sd)

arrows(1:10, means-err,1:10,means+err,code=3,angle=90)

```

So far in this section, we have shown how to modify scatter plots using `lines`, `points` etc. However, the same modifications can be applied to other types of plot too. 

```{r}

boxplot(randMat)
abline(h = 0,col="red")
points(1:10, y = seq(-3,3,length.out = 10),pch=16,col="steelblue")
text(1:10, y= seq(3,-3,length.out = 10),labels = LETTERS[1:10],col="orange")
```

```{r}
barplot(colMeans(randMat),ylim=c(-3,3))
abline(h = 0,col="red")
points(1:10, seq(-0.2, 0.6, length.out=10),col="steelblue",pch=16)
text(1:10, y= seq(0.6,-0.2,length.out = 10),labels = LETTERS[1:10],col="orange")

```


###The `par` function 


##Combining multiple plots

`par(mfrow=c...)`

###Adding a legend

`legend("topleft"....)

#Statistical Analysis

#Appendix

##Vectors

Vectors are the fundamental data type in R and are composed of an ordered group of single items of data.  There are several ways to construct a vector, but perhaps the simplest and most commonly used is `c()` function. This may seem like an unintuative name (you'll get used to some of R's idosyncracies if you use it long enough), but it stands for *concatenate* as what the function is actually doing is sticking together a number of smaller objects.

```{r}
numericVector <- c(1, 2, 3, 4)
```

When you create a variable with a single value, you are still creating a vector - it just has a length of one.  This is why we can describe vectors as the fundamental data type in R, there is nothing smaller to break them down into.

```{r}
shortVariable <- 1
shortVariable
shortVariable[1]
```

Vectors don't have to contain numbers, they work equally well for storing character data.

```{r}
characterVector <- c("one", "two", "three", "four")
```

One important thing to note is the all the values in a vector must be of the same type.  For instance you cannot have numeric and character data in the same vector.  However R won't neccessarily report and error if you try to do this, as the example below shows:

```{r}
mixedVector <- c(1, 2, "three", "four")
mixedVector
```

You can see in the output that all four values have quotation marks around them.  This indicates that R has automatically converted the numeric value to character strings.  If you wanted to keep the distinct data types you may wish to use a data frame, which we'll discuss later.

##Matrices

Sometimes it's useful to store values in two dimensions (rows and columns) rather than in a linear fashion as we can with vectors.  For example if you have an experiment with several samples and multiple time points it may make sense to store data in a format where the rows are samples and columns represent times.  

In order to achieve this we can use a matrix object.  The code below generates two small matrices, each containing the number 1 to 16.  

```{r}
matrix1 <- matrix(1:16, nrow = 4)
matrix1
```

```{r}
matrix2 <- matrix(1:16, nrow = 2)
matrix2
```

The `nrow` argument allows use to specify the dimensions of the matrix we create.  Similarly we can specify the argument `byrow` to change the order in which the values are placed in the matrix.  The default value of this agument is `FALSE`, specifying that the matrix is filled going down the columns.  In the example below we change this behaviour and fill and the values are placed going across columns instead.

```{r}
matrix(1:16, nrow = 2, byrow = TRUE)
```

As with vectors, matrices can only contain a single type of data; you can't mix numbers and characters in the same matrix.

##Data Frames

If we want to store multiple types of data in a single object with the row and column structure you might expect from a spreadsheet or printed table, we need to use a new object type: the *data frame*.  In the example below we'll create a data frame using two of the vectors created in the previous section.

```{r}
 charNumFrame <- data.frame(numericVector, characterVector)
 charNumFrame
```

## Lists

Although it's easy to think of vectors as 'lists' of values, within R a list is a distinct type of object.  Lists are used when you want to group together disparate types of information.  For example, one could store several vectors of numbers, but they need not be the same length, something that a matrix or data frame could not cope with.  Alternatively, a list could contain four elements that are a vector, a matrix, a data frame and another list respectively.

```{r}
list1 <- list(vec1 = 1:2, vec2 = 3:5, vec3 = 6:9, vec4 = 10:13)
list2 <- list(vec = 1:10, mat = matrix(1:10, nrow = 2), dat = data.frame(a = 1:5, b = 6:10), lis = list1)
```


##Subsetting

Sometimes you only want to use a subset of the data stored in an object; perhaps you only want the first five items from a long vector, or you're only interested in the second column from a data frame.  To extract a portion of an object we need to use R subsetting functionality, which is denoted by square brackets `[]`.

```{r}
 characterVector[2:3]
 matrix1[3:4, ]
```

In the example above the first line extracts the 2nd and 3rd entries from a vector, while the second line selects rows 3 and 4 from a matrix.  If we wanted to obtain the same rows, but only for the first column we'd need to specify that too:

```{r}
 matrix1[3:4, 1]
```

If you're really paying attention to the example above you'll notice that when we only select one column the format the data is printed to screen in changes. The entries are now next to each other rather than on top of one another. This is because when you only select one column R automatically gives you back a vector rather than a matrix (it assumes you don't need the second dimension).  This behaviour can sometimes be useful and sometimes frustrating, but if you want to ensure it doesn't happen you can use the `drop = FALSE` argument seen below.

```{r error=TRUE}
 matrix1[3:4, 1, drop=FALSE]
```

Extracting subsets from a list is slightly more subtle than for other object types.  Where as before we used a single set of square brackets `[ ]`, lists make use of both this and a double set of brackets `[[ ]]`.

When using a single set of brackets on a list, R will return another (probably shorter) list.  In the code below we ask for a list with only the first and third elements (the vector and data frame entries) from the example made earlier.

```{r}
list2[c(1,3)]
```

This makes sense if you're interested in getting a few entries but can be a little unintuative if you're only interested in a single element.  Asking for a single entry in the manner shown above will still retrun a list.  If you wish to reference an element directly you use the double braket notation.  This difference is demonstrated in the example below, where we use the function `is()` to ask R what type of object we've got.  

```{r}
class( list1[1] )
class( list1[[1]] )
```

##Functions

##Useful functions to know

##R version details

The version of R and the packages used in this document are given below.


```{r}
sessionInfo()
```

