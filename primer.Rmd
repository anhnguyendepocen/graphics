---
title: 'Data  Manipulation and Visualisation: An R primer'
author: "Mark Dunning and Mike Smith"
date: "09/09/2014"
output: pdf_document
toc: yes
---

#Introduction

This document will guide you through the key concepts and techniques required to manipulate and process data in R.

1. Read the data into R
  + What format are the data in? 
2. Manipulate the data
  + What columns / rows are needed for the analysis? Do any additional calculations need to be performed?
3. Plot the data
  + What type of plot do you need to convey your message? What type of data do you need for the plot
  
  
##About this document

This document was written in RStudio using the **markdown** format. If you see a section like this, you can copy-and-paste the text into RStudio and execute it. 
 
```{r eval=FALSE}
print("Hello World")
```


Often the output from R will be displayed after the R command

```{r}
print("Hello World")
```

Sometimes the graphics produced by R will be displayed too.

```{r}
plot(runif(1:10))
```

#Reading data into R

More information can be found online at the [R data manual](http://cran.r-project.org/doc/manuals/R-data.html)

##Specify a path to the file

R needs to know where the file is located on your hard drive in order to read it. If the file is located within your *working directory* then you can just specify the name of the file. You can find out the location of your working directory using the `getwd` function.

```{r eval=FALSE}
getwd()
```

You can also interrogate the contents of your working directory using the `dir` function

```{r eval=FALSE}
dir()

```
The `dir` function has a useful argument `pattern` which will list files that contain a particular *string* of text. For instance, we can list all files of type `.csv` and `.txt` in the current working directory that could potentially be read into R.

```{r eval=FALSE}
dir(pattern=".csv")
dir(pattern=".txt")
```

If the file you want to read is not in your working directory, then you will need to specify thepath to the file. A useful function in this situation is `file.choose`, which will open a dialog box allowing you to navigate to the file. The location can be stored as a variable.

```{r eval=FALSE}
myfile <- file.choose()
```

When specifying the file location manually, it has to giving within *quote marks*, as in the following example


```{r}
myfile <- "PrimerExamples/Indepentent two-sample t-test_v2_long.txt"
```

We will now discuss various ways of loading tabular data into R. The examples should cover most file types that you might encounter (e.g. csv, txt, tsv, xlsx files). If you have an example file that doesn't seem to fit any of these example, please let us know. Please note that R is not able to import GraphPad Prism files, as this file format is proprietary. You will have to use a commercial version of Prism to export the data table into a text-file. 

Once a file has been read into R, we recommend that you **check the dimensions and contents**. Sometimes R will read a file without error, but may not have been able to interpret the structure of the data correctly, which will cause problems for further analysis.

##What separator should be used?

```{r}
count.fields("PrimerExamples/Indepentent two-sample t-test_v2_long.txt",sep="\t")
count.fields("PrimerExamples/Indepentent two-sample t-test_v2_long.txt",sep=",")

```


##Tab-delimited file

As a *rule-of-thumb*, tab-delimited files have file extensions *.txt* or *.tsv*. If your file is tab-delimited and you have specified the location using the previous section, you will be able to use the `read.delim` function. The `file.exists` is a useful function for checking that the file location is correct; returning `TRUE` if so.

```{r}
myfile <- "PrimerExamples/Indepentent two-sample t-test_v2_long.txt"
file.exists(myfile)
mydata <- read.delim(myfile)
```

Assuming that the function does not produce an error, you should now have a variable `mydata` in your R workspace. This is *data frame* object, described in more detail in the [appendix](#data-frames). At this point, it is highly recommended that you check the contents of the variable. The `View` command should open a new tab in RStudio.

```{r eval=FALSE}
View(mydata)
```

The dimensions and structure of the data can be further interrogated using the following [useful functions](#useful-functions-to-know).

```{r}
dim(mydata)
str(mydata)
head(mydata)
```

In this case, the object has `r ncol(mydata)` columns and `r nrow(mydata)` rows; as we would expect.

Now notice what happens if we read the file by (incorrectly) calling the `read.csv` function on a *tab-delimited* file

```{r}
myfile <- "PrimerExamples/Indepentent two-sample t-test_v2_long.txt"
mydata <- read.csv(myfile)
dim(mydata)
str(mydata)
head(mydata)
```

R was able to read the file without error, but the dimensions of the resulting object are incorrect. In particular, it has been unable to separate the columns because an incorrect s
eparator was used (a `,` rather than a tab). 

##Comma-separated file

Files that have columns separated by commas can be read using the `read.csv` function. The file location needs to be specified by either using the `file.choose` function as follows;

```{r eval=FALSE}
myfile <- file.choose()
```

Or by specifying the path to the file within quote marks. Once the file has been read, we check the dimensions and general structure.

```{r}
myfile <- "PrimerExamples/One-sample t-test.csv"
mydata <- read.csv(myfile)

dim(mydata)
str(mydata)
head(mydata)
```


##Excel file

R is even able to read Excel spreadsheets. This requires an additional *package* to be installed; `gdata`. This package is loaded as follows;

```{r}
library(gdata)
```

It is not uncommon for a package to print text to the screen upon loading. You should not mistake this text for an *error* message.

However, if you do not have `gdata` installed you will get an error message in the following form.

```{r echo=FALSE,warning=FALSE}

error <- try(library(foo),silent = TRUE)
error[1]
```

If this error occurs, the package will need to be installed and then loaded
```{r,eval=FALSE}
install.packages("gdata")
library(gdata)
```

Note that you will only need to install the package once for a particular R *version*. However, you will need to load this library in every new R session when you require the functionality to read Excel files.

We can now call the `read.xls` function from `gdata` to create a *data frame* from your input file.

```{r}
myfile <- "PrimerExamples//Indepentent two-sample t-test_v2_long.xlsx"

mydata <- read.xls(myfile)
dim(mydata)
head(mydata)
```

##Specifying a different separator

If your file is neither `tab` or `comma` separated, then `read.csv` and `read.delim` will not be able to read the file correctly with their default arguments. In the following example, we try and use to `read.csv` on a file with columns that are separated with a space (`" "`).

```{r}
myfile <- "PrimerExamples/space-separated.csv"
mydata <- read.csv(myfile)
dim(mydata)
head(mydata)
```

We see that the dimensions of the data object are incorrect. Both `read.csv` and `read.delim` have the option to specify a different separator. 

```{r}
mydata <- read.csv(myfile, sep=" ")
dim(mydata)
head(mydata)
```


##SPSS file
R is able to read data created by SPSS. This requires an additional *package* to be installed; `foreign`. This package is loaded as follows;

```{r}
library(foreign)
```

You only need to load the library *once* per R-session. We can now call the `read.spss` function from `foreign` to create a *data frame* from your input file.

```{r}
myfile <- "PrimerExamples/p004.sav"

mydata <- read.spss(myfile,to.data.frame = TRUE)
dim(mydata)
head(mydata)
```


##Further options for reading files
Sometimes we might be faced with 'messy' data that do not have a straightforward format of rows and columns. 
`read.csv` and `read.delim` are in fact specialised versions of a generic `read.table` function. This function has many options to allow finer-grain control over how files are read into R, as you will see from the manual page. 

```{r eval=FALSE}
?read.table
```

We now summarise the options that prove to be most useful

###Skipping lines

By default, R will assume that your data table starts on the first line of the file and that the column headers are found on the first line. However, sometimes the data table can be preceeded with several lines of header information. The header may contain useful information for the user, such as the date the file was generated and software versions etc, but is not relevant when we try and read the data table into R. 

If we try and use the default settings of `read.delim` to read a tab-delimited file with arbitrary header information, the following occurs. In this case, the file contains counts for a number of barcodes deteceted on a particular lane of sequencing. Naturally, we might want to read these data into R and perform some exploratory analysis and diagnostics.

```{r}
myfile <- "PrimerExamples/file-with-header.txt"
mydata <- read.delim(myfile)
head(mydata)
```

You will notice that R has tried to interpret the header information as lines of the data table, and therfore the data is not imported correctly.

Fortunately, both `read.csv` and `read.delim` have a `skip` argument so that we can start reading the data table from a pre-determined position in the file. In this example we have to *skip* the first 11 lines of the file in order to reach the table.

```{r}
mydata <- read.delim(myfile, skip=11)
head(mydata)
```

In practice, you may have to try different values for the `skip` argument in order to obtain the correct result. Use of the `head` and `dim` functions should help you determine when the data has been read correctly.

###Files with no header

Conversely, sometimes files can be created without any column names. By default, R assumes that the first row in the file contains column headings. This can have unexpected consequences when a file does not contain column headings. 


```{r}
myfile <- "PrimerExamples/file-with-no-header.csv"
mydata <- read.csv(myfile)
head(mydata)
dim(mydata)
colnames(mydata)
```

In this example, R took the first line of the file to be the column headings and so we have column names `r paste(colnames(mydata),collapse=" & ")`. Moreover, the data frame produced has `r nrow(mydata)` rows rather than `r nrow(mydata)+1`. The remedy is to set the `header` argument to `FALSE`. Both `read.csv` and `read.delim` are able to recognise the `header` argument.

```{r}
myfile <- "PrimerExamples/file-with-no-header.csv"
mydata <- read.csv(myfile,header=FALSE)
head(mydata)
dim(mydata)
colnames(mydata)
```

You can modify the column names of the `mydata` object.

```{r}
colnames(mydata) <- c("Month", "Value")
```


###Reading a pre-determined number of lines

It is possible to read only a fixed number of rows by using the `nrows` argument. Useful if you just want to see the first few lines in a file.

```{r}
subset <- read.csv("PrimerExamples/One-sample t-test.csv",nrows=4)
subset
```



###Invalid characters

Consider the following file, which we are told has the expression levels of 20 genes. We use `read.delim` to read the file (as it is tab-delimited)

```{r}
myfile <- "PrimerExamples/DiffGenes.tsv"
mydata <- read.delim(myfile)
head(mydata)
dim(mydata)
```

However, the number of rows comes out as `r nrow(mydata)`. We can use the `tail` function (analagous to `head`) to look at the last few rows in the file.

```{r}
tail(mydata)
```

Problems of this nature are usually due to an extraneous quotation mark `"` or `'` being found somewhere in the file. We can tell `read.delim` to ignore quotation marks in the following way. Of course, we could have editted the raw data to remove the quote mark, but this might not be practical for larger files.

```{r}
mydata <- read.delim(myfile,quote = "")
```

We now look at a second example file, which upon first impressions loads without any problems.

```{r}
myfile <- "PrimerExamples/DiffGenes2.tsv"
mydata <- read.delim("PrimerExamples/DiffGenes2.tsv",header=FALSE)
head(mydata)
dim(mydata)
```
A natural data exploration step would be to calculate the mean of the gene expression values, which are stored in the second column. However, we cannot do this even if we tell R to ignore any `NA` values. We can discover that the second has not been treated as numeric values by R.

```{r}
mean(mydata[,2])
mean(mydata[,2],na.rm=TRUE)
summary(mydata[,2])
str(mydata)
```

The issue is that our collaborator has chosen to use a `?` to denote a missing value in the second column. This causes R to think that this column contains characters rather than numbers. A solution is to use the `na.strings` argument to specify a particular value that is used to denote a missing value.

```{r}
myfile <- "PrimerExamples/DiffGenes2.tsv"
mydata <- read.delim("PrimerExamples/DiffGenes2.tsv",header=FALSE,na.strings="?")

head(mydata)
str(mydata)
summary(mydata[,2])
mean(mydata[,2],na.rm=TRUE)
```



###If all else fails...

The `readLines` function can be used...

```{r}
temp <- readLines("PrimerExamples/Indepentent two-sample t-test_v2_long.txt")
head(temp)
```

```{r}
temp <- readLines("PrimerExamples/One-sample t-test.csv")
head(temp)
```


```{r}
temp <- readLines("PrimerExamples/file-with-header.txt")
head(temp)
```

```{r}
temp <- readLines("PrimerExamples/space-separated.csv")
temp
```

##Strings as factors

##Data in multiple files

#Using pre-built data

R comes with the `datasets` package which contains many example datasets ready for exploration and analysis. To see what datasets are available, along with brief descriptions, enter the following;

```{r eval=FALSE}
data()
```

If you see a dataset that might be interesting (e.g. the `DNase` dataset which measures the density of a protein at various concentrations), it can be loaded into R in the following manner. 

```{r}
data(DNase)
head(DNase)
```
Further details on the dataset can be found on its help page.
```{r eval=FALSE}
?DNase
```


```{r echo=FALSE}
par(ask=FALSE)
```

Moreover, example plots and code can be generated using the `example` function.

```{r}
example(DNase)
```

#Data manipulation

##Data subsetting

###`%in%`
A common task in exploratory data analysis is to ask whether a specific value or values exists in a larger R object.  For example you may want to know whether a specific gene name appears in a long list of names you've just read in.  To achieve this we can use the `%in%` command.

```{r eval=TRUE}
"BRCA1" %in% c("RAS", "MYC", "BRCA1", "TP53")
```

In the case above we were only interested in a single text query.  The example below demonstrates both that `%in%` is equally happy working with numeric values, and that a vector of queries can be used in a single command.  Here a vector of `TRUE` or `FALSE` values the same length as the number of queries will be returned. This is far more efficient that trying each in turn.

```{r eval=TRUE}
c(1,5,11) %in% 1:10
```

###match,

While the `%in%` command is useful for telling you whether a query appears somewhere, it doesn't specify where in the subject you will find it.  However there are several ways to achieve just this, where perhaps the most straightforward is `which()`.

```{r eval=TRUE}
which(c("RAS", "MYC", "BRCA1", "TP53") == "BRCA1")
```

However this approach falls down if one is interested in multiple queries.
```{r eval=TRUE}
which(c("RAS", "MYC", "BRCA1", "TP53") == c("BRCA1", "RAS"))
```
To avoid the confusion this could cause, it is better the employ the function `match()`


```{r eval=TRUE}
match(x = c("BRCA1", "MYC"), table = c("RAS", "MYC", "BRCA1", "TP53"))
```

###grep 


##Re-ordering data frames

##Adding new columns / variables

##Calculating summary statistics

##apply, tapply, aggregate

#Writing data to a file

#Plotting

##The plot function

`plot` is the generic function in R

##Exporting a plot

R is able to save graphics in a variety of formats..

##Changing the plot appearance

How the `par` function works....

##Creating a layout

`par(mfrow=c...)`

##Adding a legend

`legend("topleft"....)


#Appendix

##Vectors

##Data Frames

##Factors

##Subsetting

##Functions

##Useful functions to know

##R version details

The version of R and the packages used in this document are given below.


```{r}
sessionInfo()
```

